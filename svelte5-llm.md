# RUNES

Runes are special syntax elements in Svelte 5 that act as compiler directives. They have a `$` prefix and resemble functions but are not normal JavaScript functions. Example: `let message = $state('hello');`. Unlike regular functions, runes do not require imports, cannot be assigned to variables or passed as arguments, and are only valid in specific positions within `.svelte`, `.svelte.js`, or `.svelte.ts` files. The compiler enforces correct placement and usage, treating them as intrinsic language features rather than user-defined functions.

$state in Svelte 5 creates reactive state; updating it triggers UI updates. Example: `let count = $state(0); count++;`. Unlike other frameworks, `$state` values are plain variables, not objects or functions. If used with arrays or simple objects, `$state` creates a deeply reactive state proxy, allowing direct modifications like `todos[0].done = !todos[0].done;` or `todos.push({ text: 'eat lunch' });`. However, destructuring removes reactivity: `let { done } = todos[0]; done = true;` won't affect `todos[0].done`. `$state` works in class fields: `class Todo { done = $state(false); text = $state(); constructor(text) { this.text = text; } reset() { this.text = ''; this.done = false; } }`. However, binding `onclick={todo.reset}` fails due to `this` binding; use `onclick={() => todo.reset()}` or define `reset = () => { this.text = ''; this.done = false; }`. `$state.raw` prevents deep reactivity, forcing reassignment instead of mutation: `let person = $state.raw({ name: 'Heraclitus', age: 49 }); person.age += 1; // no effect person = { name: 'Heraclitus', age: 50 }; // works`. This boosts performance for large objects. `$state.snapshot(state)` returns a non-proxied copy, useful for external APIs: `console.log($state.snapshot(counter));`. JavaScript passes arguments by value; functions don't track reactive state unless using accessors: `function add(getA, getB) { return () => getA() + getB(); } let a = $state(1), b = $state(2); let total = add(() => a, () => b); console.log(total()); // 3 a = 3; b = 4; console.log(total()); // 7`. Proxies can work similarly: `function add(input) { return { get value() { return input.a + input.b; } }; } let input = $state({ a: 1, b: 2 }); let total = add(input); console.log(total.value); // 3 input.a = 3; input.b = 4; console.log(total.value); // 7`, though classes may be preferable.

$derived creates derived state: let count = $state(0); let doubled = $derived(count * 2); Expressions inside $derived(...) must be side-effect-free; modifying state (count++) inside is disallowed. Class fields can be $derived. For complex derivations, use $derived.by, which takes a function: let numbers = $state([1, 2, 3]); let total = $derived.by(() => numbers.reduce((t, n) => t + n, 0)); $derived(expression) is equivalent to $derived.by(() => expression). Dependencies are any state read synchronously inside $derived or $derived.by; when dependencies change, derived values are marked dirty and recalculated on next read. Use untrack to exclude state from dependencies. Svelte employs push-pull reactivity: state updates immediately notify dependents (push), but derived values recompute only when read (pull). If a derived value remains referentially identical, updates are skipped. Example: let count = $state(0); let large = $derived(count > 10); ensures downstream updates happen only when large changes, not when count updates.

$effect runs when state updates, useful for tasks like interacting with third-party libraries, manipulating <canvas> elements, or making network requests, but only in the browser (not during SSR). It should not update state inside the effect to avoid convoluted code and infinite update cycles. An effect is created using `$effect`, e.g., `let size = $state(50); let color = $state('#ff3e00'); let canvas; $effect(() => { const context = canvas.getContext('2d'); context.fillStyle = color; context.fillRect(0, 0, size, size); });`. $effect tracks state or derived state accessed within it and re-runs when those values change. It runs after component mount and state changes, batched in a microtask (e.g., changing color and size together causes one re-run). Effects can be used anywhere in a component as long as they're within a parent effect’s scope. Svelte internally uses effects for template logic, like updating `<h1>hello {name}!</h1>` when `name` changes. Effects can return a teardown function to clean up before the effect re-runs or when the component is destroyed. `$effect` automatically tracks synchronous reads of `$state`, `$derived`, and `$props` but ignores asynchronous reads (e.g., after `await` or inside `setTimeout`). For example, `setTimeout(() => { context.fillRect(0, 0, size, size); }, 0);` will not track `size`. Effects re-run only when the object itself changes, not when a property inside it changes. For example, reading `state.value` triggers re-runs when `state.value` changes. Conditional code inside an effect only re-runs when evaluated, so if `a` is false, `b` won’t be read, and the effect will only re-run if `a` changes. `$effect.pre` runs code before DOM updates, e.g., for autoscrolling after messages are added: `$effect.pre(() => { if (!div) return; messages.length; tick().then(() => { div.scrollTo(0, div.scrollHeight); }); });`. `$effect.tracking` tells if the code is running inside a tracking context. `$effect.root` creates a non-tracked scope for manual control of nested effects, e.g., `$effect.root(() => { $effect(() => { console.log(count); }); return () => { console.log('cleanup'); }; });`. Use `$derived` or `$derived.by` instead of $effect to synchronize state (e.g., `let doubled = $derived(count * 2);`) and avoid convoluted linking via effects. For callbacks, use functions like `updateSpent` and `updateLeft` to update values, or consider using getters and setters: `let left = { get value() { return total - spent; }, set value(v) { spent = total - v; } };`. If updating `$state` in an effect causes infinite loops, use `untrack` to bypass tracking.

$props in Svelte refers to the inputs passed to a component, which are commonly called props. You pass props to components like attributes to elements: `<MyComponent adjective="cool" />`. Inside the component, you can receive props using the `$props` rune (e.g., `let props = $props();`) or destructure them (e.g., `let { adjective } = $props();`). Destructuring props also allows you to declare fallback values, which are used if the parent component doesn’t set a given prop (e.g., `let { adjective = 'happy' } = $props();`), but fallback values are not reactive proxies. Props can be renamed using destructuring, which is necessary for invalid identifiers or JavaScript keywords (e.g., `let { super: trouper = 'lights are gonna find me' } = $props();`). Rest properties can be used to gather remaining props (e.g., `let { a, b, c, ...others } = $props();`). When a prop is passed to a child component, its reference updates reactively when the parent value changes. However, the child component can temporarily override the prop value, which is useful for ephemeral state but should not involve mutation unless the prop is bindable. Mutating a regular object prop has no effect, as shown in `let object = $props(); object.count += 1`, while mutating a reactive state proxy (e.g., `let object = $state({count: 0});`) will update the prop but trigger an `ownership_invalid_mutation` warning, as the component is mutating state it doesn't "own." The fallback value of a non-bindable prop is untouched and doesn’t turn into a reactive proxy, meaning mutations have no effect (e.g., `let { object = { count: 0 } } = $props();`). The general rule is not to mutate props; instead, use callback props or `$bindable` for shared state between parent and child. Type safety can be added by annotating props in TypeScript (e.g., `let { adjective }: { adjective: string } = $props();`) or JSDoc (`/** @type {{ adjective: string }} */ let { adjective } = $props();`), and you can define interfaces for props (e.g., `interface Props { adjective: string; } let { adjective }: Props = $props();`). Type definitions for native DOM elements are available in `svelte/elements`. Adding types is recommended for clarity on which props should be provided. The `$props.id()` rune, introduced in version 5.20.0, generates a unique ID for the component instance, ensuring consistency between server and client during hydration. This is useful for linking form elements using attributes like `for` and `aria-labelledby` (e.g., `const uid = $props.id();` in the component and `<label for="{uid}-firstname">`).

$bindable in Svelte allows component props to be bound, enabling data flow from child to parent, which is not the default behavior where props flow only from parent to child. This feature can simplify code when used sparingly but should be used carefully. With `$bindable`, a state proxy can be mutated in the child, unlike regular props where mutation is discouraged and Svelte warns against mutating state it doesn’t "own." To mark a prop as bindable, use the `$bindable` rune (e.g., `let { value = $bindable(), ...props } = $props();`). The component can then bind the value using the `bind:value={value}` directive, like in `<FancyInput bind:value={message} />`, where `message` is a reactive state. If the parent doesn't want to listen to the child, it can pass a normal prop, and a fallback value can be set for when no prop is provided, like `let { value = $bindable('fallback'), ...props } = $props();`.

$inspect in Svelte is a development-only tool that behaves like `console.log` but re-runs whenever its arguments change, tracking reactive state deeply. It can be used to monitor changes in state, such as in `let count = $state(0); let message = $state('hello'); $inspect(count, message);`, where it will log every time `count` or `message` changes. $inspect also supports the `.with` method, allowing the use of a callback instead of `console.log`. The callback is invoked with "init" or "update" as the first argument and the reactive values as subsequent arguments (e.g., `$inspect(count).with((type, count) => { if (type === 'update') { debugger; } });`). A common use is passing `console.trace` to `.with` for tracking the origin of state changes: `$inspect(...).with(console.trace);`. The `$inspect.trace` rune, introduced in version 5.14, traces the surrounding function whenever it re-runs due to reactive state changes, printing information about the reactive state that triggered the effect (e.g., `$inspect.trace();` within a `$effect()` block). An optional label can be passed to `$inspect.trace` for further identification.

$host in Svelte allows access to the host element when compiling a component as a custom element. This is useful for dispatching custom events from the component. For example, in a custom element `my-stepper`, you can use `$host()` to dispatch events like `dispatch(type) { $host().dispatchEvent(new CustomEvent(type)); }`. In the component, buttons can trigger the events like `decrement` or `increment` using `$host()`, and in the parent component, you can listen for these custom events like `<my-stepper ondecrement={() => count -= 1} onincrement={() => count += 1}></my-stepper>`. The component can modify the parent state via the events, allowing for custom event handling in the host element.

Markup in Svelte 5 extends HTML with additional functionality. Regular HTML elements use lowercase tags (`<div>`), while components use capitalized tags or dot notation (`<Widget>`, `<my.stuff>`). Example: `<script> import Widget from './Widget.svelte'; </script> <div> <Widget /> </div>`. Attributes work like in HTML, allowing unquoted values (`<input type=checkbox />`), JavaScript expressions (`<a href="page/{p}">page {p}</a>`), or boolean conditions (`<button disabled={!clickable}>...</button>`). Boolean attributes are included if truthy, omitted if falsy, while other attributes are included unless nullish. Example: `<input required={false} placeholder="This input field is not required" />`. When attribute name and value match (`name={name}`), shorthand `{name}` can be used (`<button {disabled}>...</button>`). Props in components work similarly, allowing shorthand (`<Widget foo={bar} answer={42} text="hello" />`). Spread attributes allow multiple props at once (`<Widget {...things} />`). Events are handled with `on` attributes (`<button onclick={() => console.log('clicked')}>click me</button>`). Events are case-sensitive: `onclick` listens to `click`, `onClick` listens to `Click`. Event shorthand works (`<button {onclick}>click me</button>`) and spreads apply (`<button {...thisSpreadContainsEventAttributes}>click me</button>`). Event handlers fire after bindings. Passive listeners (`ontouchstart`, `ontouchmove`) improve performance; use `on` from `svelte/events` to override (`on(event, handler)`). Svelte delegates events (`click`, `input`, `keydown`, etc.) to a single listener at the root for efficiency. Dispatched events with delegated listeners must bubble (`{ bubbles: true }`). Avoid `stopPropagation`, as it prevents delegation. `addEventListener` on root runs before declarative handlers (`onclick={...}`). Expressions inside `{}` insert dynamic text (`<h1>Hello {name}!</h1> <p>{a} + {b} = {a + b}.</p>`). `{}` can be escaped (`&lbrace;` for `{`). Regular expressions inside `{}` require parentheses (`{(/^[A-Za-z ]+$/).test(value) ? x : y}`). To insert HTML, use `{@html}` (`{@html potentiallyUnsafeHtmlString}`). HTML comments work (`<!-- comment -->`), and `svelte-ignore` disables warnings for next block (`<!-- svelte-ignore a11y_autofocus --> <input bind:value={name} autofocus />`). Special `@component` comments appear on hover in other files (`<!-- @component - Usage: ```html <Main name="Arethra"> ``` -->`).

{#if expression}...{/if} conditionally renders content; additional conditions use {:else if expression} and can end with {:else}. Example: `{#if answer === 42} <p>what was the question?</p> {/if}`. Multiple conditions: `{#if porridge.temperature > 100} <p>too hot!</p> {:else if 80 > porridge.temperature} <p>too cold!</p> {:else} <p>just right!</p> {/if}`. Blocks can wrap text within elements.

Each blocks iterate over arrays, array-like objects (anything with a `length` property), or iterables like `Map` and `Set`. Syntax: `{#each expression as name}...{/each}`; optional index: `{#each expression as name, index}...{/each}`. Example: `<ul>{#each items as item}<li>{item.name} x {item.qty}</li>{/each}</ul>`. Index usage: `{#each items as item, i}<li>{i + 1}: {item.name} x {item.qty}</li>{/each}`. Keyed each blocks use `{#each expression as name (key)}...{/each}` to uniquely identify items and optimize updates. Example: `{#each items as item (item.id)}<li>{item.name} x {item.qty}</li>{/each}`. Index can be included: `{#each items as item, i (item.id)}<li>{i + 1}: {item.name} x {item.qty}</li>{/each}`. Destructuring supported: `{#each items as { id, name, qty }, i (id)}<li>{i + 1}: {name} x {qty}</li>{/each}`. Rest patterns allowed: `{#each objects as { id, ...rest }}<li><span>{id}</span><MyComponent {...rest} /></li>{/each}`; also works with arrays: `{#each items as [id, ...rest]}<li><span>{id}</span><MyComponent values={rest} /></li>{/each}`. Iteration without binding names: `{#each expression}...{/each}` or `{#each expression, index}...{/each}`. Example of rendering a chessboard without explicitly named items: `<div class="chess-board">{#each { length: 8 }, rank}{#each { length: 8 }, file}<div class:black={(rank + file) % 2 === 1}></div>{/each}{/each}</div>`. Each blocks can include `{:else}` for empty lists: `{#each todos as todo}<p>{todo.text}</p>{:else}<p>No tasks today!</p>{/each}`.

Key blocks `{#key expression}...{/key}` force re-creation of their contents when `expression` changes. This reinstantiates and reinitializes components: `{#key value}<Component />{/key}`. Useful for triggering transitions on value changes: `{#key value}<div transition:fade>{value}</div>{/key}`.

Await blocks handle `Promise` states: pending, fulfilled, or rejected. Syntax: `{#await expression}...{:then name}...{:catch name}...{/await}`. If `expression` isn't a `Promise`, only `:then` executes, including during SSR. Example: `{#await promise}<p>waiting...</p>{:then value}<p>The value is {value}</p>{:catch error}<p>Error: {error.message}</p>{/await}`. The `:catch` block is optional if no rejection handling is needed: `{#await promise}<p>waiting...</p>{:then value}<p>The value is {value}</p>{/await}`. Omitting the pending state: `{#await promise then value}<p>The value is {value}</p>{/await}`. Only handling errors: `{#await promise catch error}<p>Error: {error}</p>{/await}`. Dynamic import example: `{#await import('./Component.svelte') then { default: Component }}<Component />{/await}`.

# TEMPLATE SYNTAX

Snippets in Svelte 5 allow reusable markup inside components, similar to function declarations with parameters and default values but without rest parameters. Declared with `{#snippet name(params)}...{/snippet}` and rendered using `{@render name(params)}`, snippets replace repetitive code. Example: replacing an `{#each}` block rendering images with a snippet `{#snippet figure(image)}...{/snippet}` and using `{@render figure(image)}` within conditions. Snippets can be declared anywhere in a component, referencing values in `<script>` or `{#each}` blocks and are lexically scoped—accessible to siblings and their children but not to enclosing elements. They can reference themselves or each other, e.g., `{#snippet countdown(n)}{#if n>0}{n}...{@render countdown(n-1)}{:else}{@render blastoff()}{/if}{/snippet}`. Snippets can be passed to components as props, allowing template-based rendering, e.g., `<Table data={fruits} {header} {row} />` where `header` and `row` are snippet props. Snippets inside a component implicitly become props, and non-snippet content inside component tags is assigned to a `children` snippet, e.g., `<Button>click me</Button>` uses `{@render children()}` inside `<button>`. Snippet props can be optional, handled via optional chaining `{@render children?.()}` or an `#if` block with fallback content. Snippets implement the `Snippet` interface in TypeScript, e.g., `interface Props {data: any[]; children: Snippet; row: Snippet<[any]>;}` with generics `<script lang="ts" generics="T"> let {data, children, row}: {data: T[]; children: Snippet; row: Snippet<[T]>;} = $props();</script>`. Snippets at the top level of a `.svelte` file can be exported from `<script module>`, provided they do not reference non-module `<script>` variables, e.g., `<script module>export {add};</script> {#snippet add(a, b)}{a} + {b} = {a + b}{/snippet}` (requires Svelte 5.5.0+). Programmatic snippets can be created using `createRawSnippet()`. Snippets replace slots, which are deprecated in Svelte 5.

The `{@render ...}` tag renders a [snippet](snippet). Example: `{#snippet sum(a, b)} <p>{a} + {b} = {a + b}</p> {/snippet} {@render sum(1, 2)} {@render sum(3, 4)} {@render sum(5, 6)}`. The expression can be an identifier like `sum` or any JavaScript expression: `{@render (cool ? coolSnippet : lameSnippet)()}`. If the snippet might be undefined, use optional chaining: `{@render children?.()}` or an `{#if ...}` block: `{#if children} {@render children()} {:else} <p>fallback content</p> {/if}`.

The `{@html ...}` tag injects raw HTML into a Svelte component: `{@html content}`. The expression must be valid standalone HTML; `{@html '<div>'}content{@html '</div>'}` is invalid because `</div>` is not standalone HTML. This does not compile Svelte code. Content rendered via `{@html ...}` is 'invisible' to Svelte and does not receive scoped styles, meaning styles inside a `<style>` block won't apply unless explicitly globalized: `<style> article { a { color: hotpink } img { width: 100% } } </style>` is ineffective because Svelte removes unused styles. Instead, use `:global`: `<style> article :global { a { color: hotpink } img { width: 100% } } </style>`.

The `{@const ...}` tag defines a local constant and is only allowed as an immediate child of a block like `{#if ...}`, `{#each ...}`, `{#snippet ...}`, a `<Component />`, or a `<svelte:boundary>`. Example: `{#each boxes as box} {@const area = box.width * box.height} {box.width} * {box.height} = {area} {/each}`.

The `{@debug ...}` tag functions as an alternative to `console.log(...)`, logging specified variable values whenever they change and pausing execution if devtools are open. Example: `<script> let user = { firstname: 'Ada', lastname: 'Lovelace' }; </script> {@debug user} <h1>Hello {user.firstname}!</h1>`. It accepts a comma-separated list of variable names but not arbitrary expressions; valid: `{@debug user}`, `{@debug user1, user2, user3}`; invalid: `{@debug user.firstname}`, `{@debug myArray[0]}`, `{@debug !isReady}`, `{@debug typeof user === 'object'}`. A standalone `{@debug}` tag inserts a `debugger` statement triggered by any state change.

The `bind:` directive enables two-way data binding from child to parent using `bind:property={expression}`, where `expression` is an _lvalue_. If the expression matches the property name, it can be omitted: `<input bind:value={value} />` is equivalent to `<input bind:value />`. Svelte sets an event listener that updates the bound value, firing existing listeners first. Most bindings are two-way, except readonly bindings. Function bindings use `bind:property={get, set}` for validation/transformation, e.g., `<input bind:value={ () => value, (v) => value = v.toLowerCase()} />`. Readonly bindings like `bind:clientWidth={null, redraw}` return `null` for `get`. `bind:value` on `<input>` syncs its `value` property, coercing numeric inputs (`type="number"`, `type="range"`) to numbers. If empty/invalid, the value is `undefined`. Since 5.6.0, `<input>` with `defaultValue` inside a form resets to that value. `<input bind:checked>` binds checkboxes/radio buttons, with `defaultChecked` supporting form resets. `<input bind:group>` links radio inputs (mutually exclusive) and checkboxes (array values), e.g., `<input type="radio" bind:group={tortilla} value="Plain" />`. `bind:files` on `<input type="file">` gets a `FileList`; modifying it requires `DataTransfer`. `<select bind:value>` binds to selected `<option>`, supporting arbitrary values and multiple selection (`<select multiple>` behaves like a checkbox group). Default selection via `selected` on `<option>` reverts on form reset unless the bound value is defined. `<audio>` and `<video>` support two-way bindings (`currentTime`, `playbackRate`, `paused`, `volume`, `muted`) and readonly ones (`duration`, `buffered`, `seekable`, `seeking`, `ended`, `readyState`), with `<video>` adding `videoWidth` and `videoHeight`. `<img>` supports readonly bindings `naturalWidth` and `naturalHeight`. `<details bind:open>` syncs its `open` property. `contenteditable` elements allow bindings for `innerHTML`, `innerText`, `textContent`. All visible elements support readonly dimension bindings (`clientWidth`, `clientHeight`, `offsetWidth`, `offsetHeight`) via `ResizeObserver`. `bind:this` assigns a reference to a DOM node, e.g., `<canvas bind:this={canvas}></canvas>`, accessible in an effect: `$effect(() => { const ctx = canvas.getContext('2d'); drawStuff(ctx); });`. Components support `bind:this`, allowing instance interaction: `<ShoppingCart bind:this={cart} /> <button onclick={() => cart.empty()}> Empty cart </button>`. Component props can be bound like elements, e.g., `<Keypad bind:value={pin} />`, with downward reactivity by default. To make a property bindable, use `$bindable()`, e.g., `let { bindableProperty = $bindable() } = $props();`. A fallback value can be provided: `let { bindableProperty = $bindable('fallback value') } = $props();`, applying only when not bound. If bound but `undefined`, a runtime error prevents ambiguity.

Actions in Svelte are functions invoked when an element is mounted using the `use:` directive, typically employing `$effect` for setup and teardown: `function myaction(node) { $effect(() => { return () => {}; }); }`. Applied as `<div use:myaction>...</div>`, actions can take arguments: `function myaction(node, data) {}` and `<div use:myaction={data}>...</div>`. Actions execute only once (not during SSR) and do not rerun on argument changes. Previously, they could return an object with `update` and `destroy` methods, but `$effect` is now preferred. The `Action` interface allows optional type parameters: the node type (`Element` for general applicability), a parameter type, and custom event handlers. Example: `function gestures(node) { $effect(() => { node.dispatchEvent(new CustomEvent('swipeleft')); node.dispatchEvent(new CustomEvent('swiperight')); }); }` with `<div use:gestures onswipeleft={next} onswiperight={prev}>...</div>`.

A _transition_ occurs when an element enters or leaves the DOM due to a state change. When a block transitions out, all elements inside remain until all transitions complete. The `transition:` directive enables bidirectional transitions, allowing smooth reversal mid-transition. Example: `import { fade } from 'svelte/transition'; let visible = $state(false);` then `<button onclick={() => visible = !visible}>toggle</button> {#if visible} <div transition:fade>fades in and out</div> {/if}`. Built-in transitions are available from `svelte/transition`. Transitions are local by default, affecting only elements within their block; `global` applies when a parent block changes. Example: `<p transition:fade>fades in and out only when y changes</p> <p transition:fade|global>fades in and out when x or y change</p>`. Transitions accept parameters: `{#if visible} <div transition:fade={{ duration: 2000 }}>fades in two seconds</div> {/if}`. Custom transitions return objects with properties like `delay`, `duration`, `easing`, `css`, and `tick`. Example: `function whoosh(node, { delay = 0, duration = 400, easing = elasticOut }) { return { delay, duration, easing, css: (t, u) => \`transform: scale(\${t})\` }; }`. Custom transitions can also modify text content dynamically: `function typewriter(node, { speed = 1 }) { const text = node.textContent; return { duration: text.length / (speed * 0.01), tick: t => { node.textContent = text.slice(0, ~~(text.length * t)); } }; }`. If a transition returns a function, it executes in the next microtask, useful for coordinated effects like crossfades. Transition functions receive `options` containing `direction` (`in`, `out`, `both`). Transition events include `introstart`, `introend`, `outrostart`, and `outroend`. Example: `<p transition:fly={{ y: 200, duration: 2000 }} onintrostart={() => (status = 'intro started')} onoutrostart={() => (status = 'outro started')} onintroend={() => (status = 'intro ended')} onoutroend={() => (status = 'outro ended')}> Flies in and out </p>`.

The `in:` and `out:` directives function like `transition:`, but transitions are not bidirectional; an `in` transition continues playing alongside the `out` transition rather than reversing if the block is outroed mid-transition. If an out transition is aborted, it restarts from scratch. Example: `<script> import { fade, fly } from 'svelte/transition'; let visible = $state(false); </script> <label> <input type="checkbox" bind:checked={visible}> visible </label> {#if visible} <div in:fly={{ y: 200 }} out:fade>flies in, fades out</div> {/if}`.

An animation is triggered when a keyed each block's contents are reordered but not when elements are added or removed. The animate directive must be on an immediate child of a keyed each block and can use Svelte's built-in or custom animation functions. Example: `{#each list as item, index (item)} <li animate:flip>{item}</li> {/each}`. Animations accept parameters as object literals: `{#each list as item, index (item)} <li animate:flip={{ delay: 500 }}>{item}</li> {/each}`. Custom animation functions receive `(node, { from, to }, params)`, where `from` and `to` are DOMRects representing the element's geometry before and after reordering. The function can return `{ delay, duration, easing, css, tick }`, where `css(t, u)` defines animation styles (`t` moves from 0 to 1 after easing; `u = 1 - t`). Example: `function whizz(node, { from, to }, params) { const dx = from.left - to.left, dy = from.top - to.top, d = Math.sqrt(dx * dx + dy * dy); return { delay: 0, duration: Math.sqrt(d) * 120, easing: cubicOut, css: (t, u) => \`transform: translate(${u * dx}px, ${u * dy}px) rotate(${t * 360}deg);\` }; }` used as `{#each list as item, index (item)} <div animate:whizz>{item}</div> {/each}`. Custom animations can also include `tick(t, u)`, which updates styles dynamically: `tick: (t, u) => Object.assign(node.style, { color: t > 0.5 ? 'Pink' : 'Blue' })`.

The `style:` directive in Svelte provides a shorthand for setting multiple styles on an element. Example: `<div style:color="red">...</div>` is equivalent to `<div style="color: red;">...</div>`. Values can be dynamic: `<div style:color={myColor}>...</div>`. The shorthand form `<div style:color>...</div>` is valid. Multiple styles can be set: `<div style:color style:width="12rem" style:background-color={darkMode ? 'black' : 'white'}>...</div>`. Use `|important` to mark a style as important: `<div style:color|important="red">...</div>`. When `style:` directives and `style` attributes are combined, directives take precedence: `<div style="color: blue;" style:color="red">This will be red</div>`.

Svelte allows setting classes using the `class` attribute or `class:` directive. Primitive values in `class` behave like normal attributes, but falsy values are stringified (`class="false"`), except `null` and `undefined`, which omit the attribute; future versions will omit all falsy values. Since Svelte 5.16, `class` can accept objects or arrays processed via `clsx`. In objects, truthy keys are added (`<div class={{ cool, lame: !cool }}>...</div>` results in `class="cool"` if `cool` is truthy, `class="lame"` otherwise). Arrays combine truthy values (`<div class={[faded && 'saturate-0 opacity-50', large && 'scale-200']}>...</div>` results in `class="saturate-0 opacity-50 scale-200"` if `faded` and `large` are truthy). Arrays can contain nested arrays or objects, which `clsx` flattens, enabling flexible composition of classes with props (`<button {...props} class={['cool-button', props.class]}>...</button>`). This allows users to mix strings, objects, and arrays (`<Button class={{ 'bg-blue-700 sm:w-1/2': useTailwind }}>...</Button>`). The `ClassValue` type (`import type { ClassValue } from 'svelte/elements'`) ensures type safety in TypeScript (`const props: { class: ClassValue } = $props();`). Before Svelte 5.16, `class:` was the preferred way to conditionally set classes (`<div class:cool={cool} class:lame={!cool}>...</div>`), which remains an alternative to objects (`<div class={{ cool, lame: !cool }}>...</div>`). Shorthand syntax allows `<div class:cool class:lame={!cool}>...</div>` when the class name matches the value.

# STYLING
Svelte components support a `<style>` element for defining CSS that is scoped to the component using a hash-based class (e.g., `.svelte-123xyz`). Scoped selectors receive a specificity increase of 0-1-0 due to the added class, meaning a `p` selector in a component overrides a global `p` selector even if the global stylesheet loads later. If the scoping class is applied multiple times, it uses `:where(.svelte-xyz123)` after the first occurrence to avoid further specificity increases. `@keyframes` defined within a component are similarly scoped using a hashed name, and `animation` rules within the component are adjusted accordingly, ensuring the keyframes are only accessible inside the component. Example: `<style> p { color: burlywood; } .bouncy { animation: bounce 10s; } @keyframes bounce { /* ... */ } </style>`.

In Svelte, global styles can be applied using `:global(...)` or `:global { ... }`. The `:global(...)` modifier applies styles to a single selector globally, e.g., `:global(body) { margin: 0; }` affects `<body>`. Scoped global styles can be applied inside component elements, e.g., `div :global(strong) { color: goldenrod; }` applies to all `<strong>` elements inside `<div>` elements of the component. Class-based targeting works as well, e.g., `p:global(.big.red) { ... }` applies to `<p>` elements with `class="big red"`, even if applied dynamically. Global `@keyframes` require `-global-` prefix, which is removed at compile time, e.g., `@keyframes -global-my-animation-name { ... }` can be referenced as `my-animation-name`. The `:global` block applies styles globally to multiple selectors, e.g., `:global { div { ... } p { ... } }` applies styles to every `<div>` and `<p>` in the app. Nested global selectors within scoped elements are also possible, e.g., `.a :global { .b .c .d { ... } }` applies `.b .c .d` styles inside `.a` elements of the component.

CSS custom properties can be passed to components both statically and dynamically: `<Slider bind:value min={0} max={100} --track-color="black" --thumb-color="rgb({r} {g} {b})" />` which desugars to `<svelte-css-wrapper style="display: contents; --track-color: black; --thumb-color: rgb({r} {g} {b})"><Slider bind:value min={0} max={100} /></svelte-css-wrapper>` and for SVG elements, it uses `<g style="--track-color: black; --thumb-color: rgb({r} {g} {b})"><Slider bind:value min={0} max={100} /></g>`. Inside the component, custom properties can be read and given fallbacks using `var(--track-color, #aaa); var(--thumb-color, blue);` in a `<style>` block. These values don't need to be set directly on the component; they work as long as they are defined on a parent element. A common approach is defining them in `:root` in a global stylesheet to apply them application-wide.

A Svelte component can have only one top-level `<style>` tag, but additional `<style>` tags can be nested inside elements or logic blocks. These nested `<style>` tags are inserted into the DOM as-is without scoping or processing. Example: `<div><style>div { color: red; }</style></div>` will apply styles globally to all `<div>` elements in the DOM.

# SPECIAL ELEMENTS

`<svelte:boundary>` introduced in Svelte 5.3.0 prevents errors from breaking the entire app by isolating failures within its scope; it catches errors during rendering, updating, or `$effect` execution but not in event handlers, `setTimeout`, or async tasks. A boundary requires either `failed` or `onerror`. `failed` renders fallback UI with the error and a `reset` function to recreate the contents: `<svelte:boundary> <FlakyComponent /> {#snippet failed(error, reset)} <button onclick={reset}>oops! try again</button> {/snippet} </svelte:boundary>`; the snippet can also be passed explicitly via `<svelte:boundary {failed}>...</svelte:boundary>`. `onerror` is a function receiving `(error, reset)`, useful for error tracking or external handling: `<svelte:boundary onerror={(e) => report(e)}> ... </svelte:boundary>` or `<script> let error = $state(null); let reset = $state(() => {}); function onerror(e, r) { error = e; reset = r; } </script> <svelte:boundary {onerror}> <FlakyComponent /> </svelte:boundary> {#if error} <button onclick={() => { error = null; reset(); }}> oops! try again </button> {/if}`. If `onerror` throws an error, a parent boundary (if present) will handle it.

`<svelte:window>` attaches event listeners to the `window` object and ensures automatic cleanup when the component is destroyed, avoiding manual event removal or `window` existence checks in SSR. It must be placed at the component's top level, not inside blocks or elements. Example: `<script> function handleKeydown(event) { alert(\`pressed the ${event.key} key\`); } </script> <svelte:window onkeydown={handleKeydown} />`. It also supports binding to `innerWidth`, `innerHeight`, `outerWidth`, `outerHeight`, `scrollX`, `scrollY`, `online` (`window.navigator.onLine` alias), and `devicePixelRatio`, with all except `scrollX` and `scrollY` being readonly: `<svelte:window bind:scrollY={y} />`.

`<svelte:document>` functions like `<svelte:window>` but attaches event listeners to `document`, useful for events like `visibilitychange` that do not fire on `window`. It also supports [actions](use) on `document`. This element must be placed at the top level of a component, never inside blocks or elements. Example: `<svelte:document onvisibilitychange={handleVisibilityChange} use:someAction />`. It allows binding to `activeElement`, `fullscreenElement`, `pointerLockElement`, and `visibilityState`, all of which are readonly.

`<svelte:body>` attaches event listeners to `document.body`, useful for events like `mouseenter` and `mouseleave` that do not fire on `window`. It also supports [actions](use) on the `<body>` element. Like `<svelte:window>` and `<svelte:document>`, it must be placed at the top level of a component and not inside blocks or elements. Example: `<svelte:body onmouseenter={handleMouseenter} onmouseleave={handleMouseleave} use:someAction />`.

`<svelte:head>` allows inserting elements into `document.head`, with `head` content exposed separately during server-side rendering. Like `<svelte:window>`, `<svelte:document>`, and `<svelte:body>`, it must be placed at the top level of a component and never inside blocks or elements. Example: `<svelte:head> <title>Hello world!</title> <meta name="description" content="This is where the description goes for SEO" /> </svelte:head>`.

`<svelte:element this={expression} />` allows rendering an element dynamically determined at runtime, useful for elements sourced from a CMS; all properties and event listeners apply as usual; only `bind:this` is supported since Svelte's built-in bindings don't work with generic elements; if `this` is nullish, the element and children are not rendered; if `this` is a [void element] (e.g., `br`) and contains children, a runtime error occurs in development: `let tag = $state('hr'); <svelte:element this={tag}>Invalid text</svelte:element>`; Svelte infers namespaces but if uncertain, use `xmlns`: `<svelte:element this={tag} xmlns="http://www.w3.org/2000/svg" />`; `this` must be a valid DOM tag, invalid values like `#text` or `svelte:head` are not supported.

`<svelte:options>` sets per-component compiler options: `runes={true}` enforces runes mode (see [Legacy APIs](legacy-overview)), `runes={false}` enforces legacy mode, `namespace="..."` sets the component's namespace (`"html"` by default, `"svg"`, or `"mathml"`), `customElement={...}` provides options when compiling as a custom element; if a string is given, it is used as the `tag` option, `css="injected"` makes the component inject styles inline—during SSR, styles are inserted as a `<style>` tag in `<head>`, and during CSR, styles load via JavaScript: `<svelte:options customElement="my-custom-element" />`; deprecated in Svelte 5 and non-functional in runes mode: `immutable={true}` assumes immutable data for referential equality checks, `immutable={false}` (default) makes Svelte more cautious about mutable changes, `accessors={true}` adds getters and setters for props, `accessors={false}` (default) omits them.

# RUNTIME

A _store_ in Svelte is an object enabling reactive value access via a store contract. The `svelte/store` module provides minimal store implementations. Stores can be accessed inside components using the `$` prefix, which declares the variable, subscribes to the store at initialization, and unsubscribes when appropriate. Assigning to `$`-prefixed variables requires a writable store and calls its `.set` method. Stores must be declared at the component's top level, not inside conditional blocks or functions. Example: `const count = writable(0); console.log($count); count.set(1); console.log($count); $count = 2; console.log($count);`. Stores were previously the main solution for cross-component reactive states, but Svelte 5 runes reduce their necessity. Runes enable universal reactivity outside components and in JavaScript/TypeScript files (`.svelte.js` or `.svelte.ts`). For shared state, use `$state`: `export const userState = $state({ name: 'name' });` and in a component: `<p>User name: {userState.name}</p><button onclick={() => { userState.name = 'new name'; }}>change name</button>`. Stores remain useful for complex async data streams or controlled updates. The `svelte/store` module provides `writable`, `readable`, `derived`, `readonly`, and `get`. `writable` creates a store with `set` and `update` methods. Example: `const count = writable(0); count.subscribe(console.log); count.set(1); count.update(n => n + 1);`. An optional function argument executes when the subscriber count goes from 0 to 1, receiving `set` and `update` functions, and must return a cleanup function: `const count = writable(0, () => { console.log('got a subscriber'); return () => console.log('no more subscribers'); }); count.set(1); const unsubscribe = count.subscribe(console.log); unsubscribe();`. `readable` creates a store whose value cannot be externally set: `const time = readable(new Date(), set => { const interval = setInterval(() => set(new Date()), 1000); return () => clearInterval(interval); });`. `derived` computes values from other stores: `const doubled = derived(a, $a => $a * 2);`. It supports async values with `set` and `update`: `const delayed = derived(a, ($a, set) => { setTimeout(() => set($a), 1000); }, 2000);`. It also supports cleanup functions: `const tick = derived(frequency, ($frequency, set) => { const interval = setInterval(() => { set(Date.now()); }, 1000 / $frequency); return () => clearInterval(interval); }, 2000);`. Multiple stores can be combined: `const summed = derived([a, b], ([$a, $b]) => $a + $b);`. `readonly` creates a read-only store: `const writableStore = writable(1); const readableStore = readonly(writableStore); readableStore.subscribe(console.log); writableStore.set(2); readableStore.set(2); // ERROR`. `get` retrieves a store’s value without subscribing: `const value = get(store);`. The _store contract_ requires a `.subscribe` method that calls the subscription function synchronously with the store’s current value and later on value changes. `.subscribe` must return an unsubscribe function. A store may optionally have a `.set` method, which synchronously updates the value and calls subscriptions. Stores can also be interoperable with RxJS Observables by allowing `.subscribe` to return an object with an `.unsubscribe` method, though Svelte treats stores as `undefined` until synchronously initialized.

Svelte provides `context` primitives to manage state beyond component scope, avoiding pitfalls of global state. While global state can be imported (`export const myGlobalState = $state({...})`), it is unsafe for server-side rendering as state might leak between sessions. Instead, use `setContext('key', value)` in a parent component to associate an object with its component tree and retrieve it in children using `getContext('key')`. This ensures state remains scoped and prevents unintended global usage. Context itself is not reactive, but passing a `$state` object makes its properties reactive (e.g., `setContext('counter', $state({ count: 0 }))`, accessed as `const value = getContext('counter')` in children). To check if a key exists in context, use `hasContext('key')`. Retrieve all contexts from the nearest parent with `getAllContexts()`, useful for dynamically created components. To manage context efficiently in larger applications, encapsulate interactions using functions and TypeScript symbols (e.g., `const userKey = Symbol('user'); export function setUserContext(user) { setContext(userKey, user); } export function getUserContext() { return getContext(userKey); }`). This approach maintains clarity and safety while managing scoped state.

In Svelte 5, the component lifecycle has only two phases: creation and destruction. State updates are handled by render effects rather than component-level hooks. Consequently, there are no "before update" or "after update" hooks. `onMount` schedules a callback to run when the component is mounted but does not execute in server-side components: `import { onMount } from 'svelte'; onMount(() => { console.log('mounted'); });`. If `onMount` returns a function, it runs on unmount: `onMount(() => { const interval = setInterval(() => console.log('beep'), 1000); return () => clearInterval(interval); });`. `onDestroy` schedules a callback before unmounting and is the only lifecycle hook that runs server-side: `import { onDestroy } from 'svelte'; onDestroy(() => console.log('destroying'));`. Since there's no "after update" hook, `tick` ensures the UI updates before proceeding: `import { tick } from 'svelte'; $effect.pre(() => { console.log('before update'); tick().then(() => console.log('after update')); });`. The deprecated `beforeUpdate` and `afterUpdate` hooks from Svelte 4 are unavailable in rune-based components: `import { beforeUpdate, afterUpdate } from 'svelte'; beforeUpdate(() => console.log('before update')); afterUpdate(() => console.log('after update'));`. Instead, use `$effect.pre` for `beforeUpdate` and `$effect` for `afterUpdate` since they track only relevant state changes. For instance, in a chat window that auto-scrolls when new messages appear, use `$effect.pre` to detect when `messages` changes without reacting to `theme`: `import { tick } from 'svelte'; let theme = $state('dark'); let messages = $state([]); let viewport; $effect.pre(() => { messages; const autoscroll = viewport && viewport.offsetHeight + viewport.scrollTop > viewport.scrollHeight - 50; if (autoscroll) tick().then(() => viewport.scrollTo(0, viewport.scrollHeight)); }); function handleKeydown(event) { if (event.key === 'Enter') { const text = event.target.value; if (text) { messages = [...messages, text]; event.target.value = ''; } } } function toggle() { toggleValue = !toggleValue; }`. This approach prevents unnecessary updates and ensures better performance.

Svelte's imperative component API enables mounting, unmounting, rendering, and hydrating components. `mount(App, { target, props })` instantiates and attaches a component to a DOM element; multiple components can be mounted per page. Unlike `new App(...)` in Svelte 4, effects (including `onMount` and actions) do not run automatically—use `flushSync()` to trigger them. `unmount(component, { outro })` removes a mounted component, optionally playing transitions if `outro: true`, returning a `Promise` that resolves when transitions complete or immediately otherwise. `render(App, { props })`, available only on the server when using the `server` option, returns `{ body, head }` for SSR-generated HTML. `hydrate(App, { target, props })` behaves like `mount` but reuses pre-rendered HTML from SSR output, making it interactive; effects will not run automatically—use `flushSync()` if needed.

# MISC

Svelte supports various testing strategies using frameworks like Vitest, Jasmine, Cypress, and Playwright. Unit tests check isolated code parts, while integration tests verify multiple components working together. With Vite, install Vitest via `npm install -D vitest` and modify `vite.config.js` to use `import { defineConfig } from 'vitest/config'; export default defineConfig({ resolve: process.env.VITEST ? { conditions: ['browser'] } : undefined });`. A unit test example: `import { expect, test } from 'vitest'; import { multiplier } from './multiplier.svelte.js'; test('Multiplier', () => { let double = multiplier(0, 2); expect(double.value).toEqual(0); double.set(5); expect(double.value).toEqual(10); });`. Function implementation: `export function multiplier(initial, k) { let count = $state(initial); return { get value() { return count * k; }, set: (c) => { count = c; } }; }`. Vitest allows runes in `.svelte.test.js` files: `let count = $state(0); let double = multiplier(() => count, 2); count = 5; expect(double.value).toEqual(10);`. If testing code with effects, wrap it inside `$effect.root`: `const cleanup = $effect.root(() => { let count = $state(0); let log = logger(() => count); flushSync(); expect(log.value).toEqual([0]); count = 1; flushSync(); expect(log.value).toEqual([0, 1]); }); cleanup();`. Function implementation: `export function logger(getValue) { let log = $state([]); $effect(() => { log.push(getValue()); }); return { get value() { return log; } }; }`. Component testing requires installing jsdom (`npm install -D jsdom`) and modifying `vite.config.js` with `environment: 'jsdom'`. A test using low-level DOM manipulation: `import { mount, unmount } from 'svelte'; import { expect, test } from 'vitest'; import Component from './Component.svelte'; test('Component', () => { const component = mount(Component, { target: document.body, props: { initial: 0 } }); expect(document.body.innerHTML).toBe('<button>0</button>'); document.body.querySelector('button').click(); flushSync(); expect(document.body.innerHTML).toBe('<button>1</button>'); unmount(component); });`. The same test using `@testing-library/svelte`: `import { render, screen } from '@testing-library/svelte'; import userEvent from '@testing-library/user-event'; import { expect, test } from 'vitest'; import Component from './Component.svelte'; test('Component', async () => { const user = userEvent.setup(); render(Component); const button = screen.getByRole('button'); expect(button).toHaveTextContent(0); await user.click(button); expect(button).toHaveTextContent(1); });`. End-to-end (E2E) tests use Playwright, installable via `npm init playwright` or `npx sv create`. Modify `playwright.config.js` to define the server setup: `export default { webServer: { command: 'npm run build && npm run preview', port: 4173 }, testDir: 'tests', testMatch: /(.+\.)?(test|spec)\.[jt]s/ };`. Example test: `import { expect, test } from '@playwright/test'; test('home page has expected h1', async ({ page }) => { await page.goto('/'); await expect(page.locator('h1')).toBeVisible(); });`. Cypress or NightwatchJS are also options for E2E testing.

You can use TypeScript in Svelte components by adding `lang="ts"` to `<script>` tags, enabling type-only features like annotations and interfaces while excluding enums, access modifiers with initializers, and non-standard ECMAScript features. Use a preprocessor like `vitePreprocess` in `svelte.config.js` to support these features: `import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'; const config = { preprocess: vitePreprocess({ script: true }) }; export default config;`. For SvelteKit, scaffold with `npx sv create` and select TypeScript, or use `npm create vite@latest` with `svelte-ts`. Other build tools like Rollup (`rollup-plugin-svelte`) and Webpack (`svelte-loader`) require `typescript` and `svelte-preprocess`. Configure `tsconfig.json` with `target: "ES2022"`, `verbatimModuleSyntax: true`, and `isolatedModules: true`. `$props` can be typed using interfaces: `interface Props { requiredProperty: number; optionalProperty?: boolean; snippetWithStringArgument: Snippet<[string]>; eventHandler: (arg: string) => void; [key: string]: unknown; } let { requiredProperty, optionalProperty, snippetWithStringArgument, eventHandler, ...everythingElse }: Props = $props();`. Generic `$props` can be declared with the `generics` attribute: `<script lang="ts" generics="Item extends { text: string }"> interface Props { items: Item[]; select(item: Item): void; } let { items, select }: Props = $props(); </script>`. Wrapper components exposing native attributes use `svelte/elements`: `import type { HTMLButtonAttributes } from 'svelte/elements'; let { children, ...rest }: HTMLButtonAttributes = $props();`. `$state` variables are typed as `let count: number = $state(0);`, requiring type assertions if undefined initially: `count = $state() as number;`. The `Component` type can restrict props for dynamic components: `interface Props { DynamicComponent: Component<{ prop: string }>; } let { DynamicComponent }: Props = $props();`. Extract component props with `ComponentProps`: `import type { Component, ComponentProps } from 'svelte'; import MyComponent from './MyComponent.svelte'; function withProps<TComponent extends Component<any>>(component: TComponent, props: ComponentProps<TComponent>) {}`. Declare constructor or instance types: `let componentConstructor: typeof MyComponent = MyComponent; let componentInstance: MyComponent;`. Enhance built-in DOM types for experimental attributes/events in `d.ts`: `declare namespace svelteHTML { interface IntrinsicElements { 'my-custom-element': { someattribute: string; 'on:event': (e: CustomEvent<any>) => void }; } interface HTMLAttributes<T> { mycustomattribute?: any; } }`. Ensure `d.ts` is included in `tsconfig.json`. Augment `svelte/elements`: `declare module 'svelte/elements' { export interface SvelteHTMLElements { 'custom-button': HTMLButtonAttributes; } export interface HTMLButtonAttributes { veryexperimentalattribute?: string; } }`. Reload TypeScript for changes to take effect.

Svelte components can be compiled to custom elements using `<svelte:options customElement="my-element" />`. Props are accessed via `$props()`, and slot elements allow content insertion. Inner components without a tag name remain standard Svelte components. Consumers can define elements with `customElements.define('my-element', MyElement.element)`, enabling usage as regular DOM elements: `document.body.innerHTML = '<my-element><p>Content</p></my-element>'`. Props are accessible as element properties: `el.name = 'everybody'`. All properties must be explicitly listed; otherwise, Svelte cannot expose them. Custom elements wrap Svelte components, handling their lifecycle. The inner component initializes after `connectedCallback` is invoked, and props assigned before DOM insertion are stored and applied on creation. Exported functions cannot be invoked before mounting unless the `extend` option is used. Shadow DOM updates occur on the next tick to enable batching and prevent premature unmounting. The inner component is destroyed in the next tick after `disconnectedCallback`. Custom elements support options in `<svelte:options customElement={{...}}>`, including `tag`, `shadow: "none"` to disable shadow DOM, `props` for attribute mapping, `reflect: true` to sync prop changes with attributes, `type` to define data types, and `extend` for class modifications. Example: `<svelte:options customElement={{ tag: 'custom-element', shadow: 'none', props: { name: { reflect: true, type: 'Number', attribute: 'element-index' } }, extend: (customElementConstructor) => class extends customElementConstructor { static formAssociated = true; constructor() { super(); this.attachedInternals = this.attachInternals(); } randomIndex() { this.elementIndex = Math.random(); } } }}/>` Custom elements encapsulate styles unless `shadow: "none"` is set, preventing global styles from applying. Styles are inlined rather than extracted. They are unsuitable for SSR due to the shadow DOM being invisible until JavaScript loads. Slotted content always renders in the DOM, regardless of conditional blocks. The `let:` directive does not work, as custom elements cannot pass data to parents. Older browsers require polyfills. Context APIs work within but not across custom elements. Properties prefixed with `on` are treated as event listeners rather than attributes (`<custom-element oneworld={true}>` is interpreted as `addEventListener('eworld', true)`).

Svelte 5 introduces an overhauled reactivity system with runes API, where variables are reactive using $state (e.g., let count = $state(0)) and derived state with $derived (e.g., $derived(count * 2)). Side effects are handled with $effect (e.g., $effect(() => { if (count > 5) { alert('Count is too high!'); } })). Component properties now use $props with destructuring (e.g., let { optional = 'unset', required } = $props()) and event handlers are properties (e.g., on:click becomes onclick). Component events are handled via callback props instead of createEventDispatcher (e.g., <Pump on:inflate={(power) => { size += power.detail; }} />). Snippets replace slots for content passing (e.g., {#snippet foo()}), and event handlers use wrapper functions for modifiers. The migration script automates many changes, including transitioning to runes and updating event handling. Manual adjustments are needed for certain cases like beforeUpdate, afterUpdate, and createEventDispatcher. Components are now functions instead of classes, with instantiation using mount or hydrate (e.g., mount(App, { target: document.getElementById("app") })). The legacy createClassComponent can be used for backwards compatibility. Svelte 5 requires modern browsers and enforces stricter syntax for HTML and attribute bindings, such as quoting complex values (<Component prop="this{is}valid" />). The contenteditable behavior now fully controls the binding, preventing updates from other reactive values. Multiple event handlers require manual chaining (e.g., onclick={(e) => { one(e); two(e); }}), and bind:this no longer returns component instances but the exported functions. The use of <svelte:component> is no longer necessary as components are dynamically handled (e.g., <Thing />). Component rendering is done using render from svelte/server in SSR, with CSS handled separately. Bindings are now reset on form resets, and event delegation requires careful handling to avoid missing event propagation. Other breaking changes include stricter HTML structure, validation for @const, scoped selectors for :is(...), and removal of certain compiler options like hydratable and enableSourcemap. Hydration mismatches are no longer automatically repaired, and event attributes replace directives, with on:event attributes being delegated. Svelte 5 also replaces --style-props with <svelte-css-wrapper>.

Don't use implicit let for reactivity: Use $state instead.
Don't use $: for derived values or effects: Use $derived or $effect instead.
Don't declare props with export let: Use let { prop } = $props() instead.
Don't use on:click for events: Use onclick (no colon) instead.
Don't use createEventDispatcher for component events: Pass callback props instead.
Don't use <slot> for content passing: Use snippets {#snippet} and {@render} instead.
Don't instantiate components with new Component(): Use mount(Component, {}) instead.

# REFERENCE

Svelte 5 replaces `SvelteComponent` with `Component`, removing class-based components. Use `mount` instead of instantiating via `new`. Deprecated methods include `$destroy()`, `$on()`, and `$set()`, which exist only for legacy compatibility. The `SvelteComponentTyped` type is also deprecated; use `Component<Props, Exports, Bindings>` instead. Lifecycle functions have changed: `afterUpdate(fn)` and `beforeUpdate(fn)` are replaced by `$effect` and `$effect.pre`, respectively. `createEventDispatcher` is deprecated; use callback props or `$host()`. Event dispatchers created with `createEventDispatcher` do not bubble and use `CustomEvent`. `createRawSnippet(fn)` generates snippets programmatically, returning an object with `render()` and optional `setup()`. `flushSync(fn?)` flushes pending updates synchronously, returning `void` if no callback is provided or the callback’s result otherwise. `getAllContexts()` retrieves a parent component’s entire context map and must be called during initialization. `getContext(key)` fetches a specific value, and `hasContext(key)` checks whether a key has been set. `hydrate(component, options)` mounts a component on a target, potentially with SSR hydration, and returns the component's exports and optionally props if compiled with `accessors: true`. `mount(component, options)` attaches a component to a DOM target, optionally playing transitions unless `intro: false`. `onDestroy(fn)` schedules cleanup before the component is removed and is the only lifecycle method that runs in SSR. `onMount(fn)` runs once after mounting; if the callback returns a function, it executes on unmount. `setContext(key, context)` stores a context value accessible via `getContext`. `tick()` returns a promise resolving after pending state changes have been applied. `unmount(component, { outro })` removes a component mounted via `mount` or `hydrate`, returning a promise if `outro: true`, or `void` otherwise. `untrack(fn)` ensures that state inside `fn` is not treated as a dependency within `$effect` or `$derived`. The new `Component<Props, Exports, Bindings>` type supports strong typing for Svelte components. `element?: typeof HTMLElement` is present if the component is compiled as a custom element. `ComponentConstructorOptions` is deprecated; use `mount`. `ComponentEvents` is removed; use `ComponentProps`. `ComponentInternals` is an internal branded type. `ComponentProps<Component>` extracts the expected props of a component, useful for ensuring type safety when passing props dynamically. `ComponentType<Component>` is obsolete under the new system. `EventDispatcher<EventMap>` defines event dispatching within components. `MountOptions<Props>` defines accepted options for `mount()`, including `target`, optional `anchor`, deprecated `events`, `context`, and `intro`. `Snippet<Parameters>` represents `#snippet` blocks, enforceable through type constraints, and can only be used via `{@render ...}`. This transition moves away from class-based components in favor of function-based composition with explicit lifecycle management, state handling, and context sharing.

Svelte actions are functions executed when an element is created, typed using `Action<Element, Parameter, Attributes>`. Example: `export const myAction: Action<HTMLDivElement, { someProperty: boolean } | undefined> = (node, param = { someProperty: true }) => {}`. If an action has no parameters, use `Action<HTMLDivElement>` or `Action<HTMLDivElement, undefined>`. Actions can return an object with optional `update` and `destroy` methods and specify additional attributes/events via `ActionReturn<Parameter, Attributes>`. The `update` method runs when the parameter changes after Svelte updates the DOM. The `destroy` method executes when the element unmounts. Example: `interface Attributes { newprop?: string; 'on:event': (e: CustomEvent<boolean>) => void; } export function myAction(node: HTMLElement, parameter: Parameter): ActionReturn<Parameter, Attributes> { return { update: (updatedParameter) => {...}, destroy: () => {...} }; }`. `ActionReturn<Parameter, Attributes>` allows defining available attributes/events at the TypeScript level without affecting runtime behavior.

The `flip` function in `svelte/animate` calculates the initial and final positions of an element and animates the transition using translation of x and y values. It follows the First, Last, Invert, Play (FLIP) animation principle. Syntax: `flip(node: Element, { from, to }: { from: DOMRect; to: DOMRect; }, params?: FlipParams): AnimationConfig;`. `AnimationConfig` defines optional properties: `delay?: number`, `duration?: number`, `easing?: (t: number) => number`, `css?: (t: number, u: number) => string`, and `tick?: (t: number, u: number) => void`. `FlipParams` allows additional control with `delay?: number`, `duration?: number | ((len: number) => number)`, and `easing?: (t: number) => number`.

`svelte/compiler` exports `{ VERSION, compile, compileModule, migrate, parse, preprocess, walk }`. `VERSION` is the current version from `package.json`. `compile(source, options)` generates a JS module from `.svelte` source exporting a component. `compileModule(source, options)` transforms JS with runes into a module. `migrate(source, { filename, use_ts })` attempts to convert Svelte code to runes, event attributes, and render tags, throwing errors if too complex. `parse(source, { filename, modern, loose })` returns an AST, where `modern: false` (default in Svelte 5) returns a legacy AST, switching to `true` by default in Svelte 6. `preprocess(source, preprocessor, { filename })` applies transformations like converting `<style lang="sass">` to CSS. `walk()` is deprecated in favor of `estree-walker`. `AST` namespace defines various AST nodes, including `BaseNode` (common properties `type`, `start`, `end`), `Root` (holds `options`, `fragment`, `css`, `instance`, `module`), `Fragment` (contains nodes: `Text`, `Tag`, `ElementLike`, `Block`, `Comment`), and numerous directives (`AnimateDirective`, `BindDirective`, `ClassDirective`, `LetDirective`, `OnDirective`, `StyleDirective`, `TransitionDirective`, `UseDirective`). Elements like `Component`, `SlotElement`, `RegularElement`, `SvelteComponent`, `SvelteElement`, `SvelteFragment`, `SvelteHead`, and directives such as `ConstTag`, `DebugTag`, `RenderTag` are included. Blocks (`EachBlock`, `IfBlock`, `AwaitBlock`, `KeyBlock`, `SnippetBlock`) manage control flow, while `Attribute`, `SpreadAttribute`, and `Directive` handle element properties. `CompileError` extends `ICompileDiagnostic`. `CompileOptions` includes `name` (JS class name), `customElement` (`true` generates a custom element), `accessors` (`true` creates getters/setters, default `false`, deprecated in runes mode), `namespace` (default `"html"`), `immutable` (`true` assumes no object mutations, deprecated in runes mode), `css` (`"injected"` injects styles into `head`, `"external"` keeps CSS separate for better performance), `cssHash` (function for generating class names), `preserveComments` (`true` keeps HTML comments), `preserveWhitespace` (`true` maintains whitespace), `runes` (forces runes mode, default inferred from code, always `true` for JS/TS modules), `discloseVersion` (`true` exposes Svelte major version via `window.__svelte.v`), `compatibility.componentApi` (`4 | 5`, default `5` for class-based components like Svelte 4), `sourcemap` (merged with final output), `outputFilename` (JS sourcemap name), `cssOutputFilename` (CSS sourcemap name), `hmr` (`true` enables hot reloading), `modernAst` (`true` enables modern AST, default `false`, will be `true` in Svelte 6). `CompileResult` contains `js.code` (compiled JS), `js.map` (sourcemap), `css.code/map` (compiled CSS), `warnings` (array of `{ code, message, start, end }`), `metadata.runes` (`true` if runes mode inferred), `ast` (parsed AST). `MarkupPreprocessor` takes `{ content, filename }` and returns processed content. `ModuleCompileOptions` includes `dev` (`true` adds runtime checks, default `false`), `generate` (`"client"` for browser, `"server"` for SSR, `false` disables generation), `filename` (debugging hints, set by bundler), `rootDir` (default `process.cwd()`), `warningFilter(warning)` (returns `true` to keep, `false` to discard). `Preprocessor` handles `{ content, attributes, markup, filename }`, returning `{ code, map, dependencies, attributes, toString }`. `PreprocessorGroup` groups preprocessors (`markup`, `style`, `script`). `Processed` includes `code` (processed content), `map` (sourcemap), `dependencies` (files to watch), `attributes` (updated tag attributes), `toString()`. `Warning` extends `ICompileDiagnostic`.

The `svelte/easing` module provides multiple easing functions for animation transitions. Importable functions include `backIn(t: number): number`, `backInOut(t: number): number`, `backOut(t: number): number`, `bounceIn(t: number): number`, `bounceInOut(t: number): number`, `bounceOut(t: number): number`, `circIn(t: number): number`, `circInOut(t: number): number`, `circOut(t: number): number`, `cubicIn(t: number): number`, `cubicInOut(t: number): number`, `cubicOut(t: number): number`, `elasticIn(t: number): number`, `elasticInOut(t: number): number`, `elasticOut(t: number): number`, `expoIn(t: number): number`, `expoInOut(t: number): number`, `expoOut(t: number): number`, `linear(t: number): number`, `quadIn(t: number): number`, `quadInOut(t: number): number`, `quadOut(t: number): number`, `quartIn(t: number): number`, `quartInOut(t: number): number`, `quartOut(t: number): number`, `quintIn(t: number): number`, `quintInOut(t: number): number`, `quintOut(t: number): number`, `sineIn(t: number): number`, `sineInOut(t: number): number`, and `sineOut(t: number): number`. These functions take a progress parameter `t` (ranging from 0 to 1) and return a transformed value, defining various acceleration and deceleration effects for animations.

The `svelte/events` module provides the `on` function to attach event handlers to various targets, ensuring proper execution order relative to declarative handlers using event delegation. It returns a function that removes the handler when called. The available signatures include `on(window: Window, type: keyof WindowEventMap, handler: (this: Window, event: WindowEventMap[Type]) => any, options?: AddEventListenerOptions): () => void`, `on(document: Document, type: keyof DocumentEventMap, handler: (this: Document, event: DocumentEventMap[Type]) => any, options?: AddEventListenerOptions): () => void`, `on(element: HTMLElement, type: keyof HTMLElementEventMap, handler: (this: Element, event: HTMLElementEventMap[Type]) => any, options?: AddEventListenerOptions): () => void`, `on(element: MediaQueryList, type: keyof MediaQueryListEventMap, handler: (this: Element, event: MediaQueryListEventMap[Type]) => any, options?: AddEventListenerOptions): () => void`, and `on(element: EventTarget, type: string, handler: EventListener, options?: AddEventListenerOptions): () => void`. These allow binding events to `window`, `document`, `HTMLElement`, `MediaQueryList`, or any `EventTarget`, supporting optional event listener options.

`svelte/motion` provides animated value wrappers. `Spring` creates a value that moves dynamically toward its target based on `stiffness` and `damping`. Example: `const spring = new Spring(0);` where `spring.target` sets the goal and `spring.current` updates dynamically. `Spring.of(fn, options?)` binds to `fn` and requires an effect root. `spring.set(value, options?)` updates `target`, with `options.instant` setting `current` immediately and `options.preserveMomentum` continuing motion. `precision`, `stiffness`, and `damping` control behavior. `Tween` smoothly interpolates between values with `delay`, `duration`, and `easing`. Example: `const tween = new Tween(0);` with `tween.target` defining the goal and `tween.current` updating accordingly. `Tween.of(fn, options?)` binds values dynamically. `tween.set(value, options?)` updates `target`, returning a `Promise` that resolves when `current` matches. `prefersReducedMotion` is a `MediaQuery` detecting user settings, e.g., `fly={{ y: prefersReducedMotion.current ? 0 : 200 }}` for motion adjustments. The legacy `spring` function (`spring(value?, opts?)`) and `tweened(value?, defaults?)` are deprecated in favor of `Spring` and `Tween`. The `Spring` and `Tweened` interfaces extend `Readable<T>`, supporting `set(value, opts?)`, with legacy support for `update(fn, opts?)` and `subscribe(fn)`, now deprecated.

The `svelte/reactivity/window` module exports reactive versions of `window` properties, each with a `.current` property that updates reactively in templates, derived stores, and effects without requiring `<svelte:window>` bindings or manual event listeners. Example: `import { innerWidth, innerHeight } from 'svelte/reactivity/window';` then use `{innerWidth.current}x{innerHeight.current}` in markup. Available since Svelte 5.11.0, these properties include `devicePixelRatio.current`, which reflects `window.devicePixelRatio` but behaves differently across browsers (responds to zoom level in Chrome but not in Firefox/Safari) and is `undefined` on the server. `innerHeight.current` and `innerWidth.current` mirror `window.innerHeight` and `window.innerWidth`, respectively, both reactive and `undefined` on the server. `online.current` reflects `navigator.onLine`, also `undefined` on the server. `outerHeight.current` and `outerWidth.current` provide reactive views of `window.outerHeight` and `window.outerWidth`, respectively. `screenLeft.current` and `screenTop.current` update reactively from `window.screenLeft` and `window.screenTop` inside `requestAnimationFrame`, ensuring smooth tracking of screen position changes. `scrollX.current` and `scrollY.current` mirror `window.scrollX` and `window.scrollY`, providing reactive access to scroll positions. All values are `undefined` on the server. These properties simplify reactivity by eliminating the need for manual listeners or bindings while ensuring seamless updates in Svelte applications.

Svelte provides reactive versions of `Map`, `Set`, and `URL` as `SvelteMap`, `SvelteSet`, and `SvelteURL`, importable from `svelte/reactivity` and usable like their native counterparts: `const url = new SvelteURL('https://example.com/path');` allows binding to `protocol`, `hostname`, `pathname`, and `href` in Svelte components. Other available imports include `MediaQuery`, `SvelteDate`, `SvelteURLSearchParams`, and `createSubscriber`. `MediaQuery`, available since 5.7.0, creates a media query object with a reactive `current` property reflecting its state, though it cannot determine the correct value during SSR, which may cause hydration mismatches. Usage: `const large = new MediaQuery('min-width: 800px');` where `large.current` determines if the screen is "large" or "small". Constructor: `new MediaQuery(query: string, fallback?: boolean)`. `SvelteDate` extends `Date`, constructed with `new SvelteDate(...params)`. `SvelteMap<K, V>` extends `Map<K, V>` and is instantiated via `new SvelteMap(iterable?)`, supporting `set(key, value)`. `SvelteSet<T>` extends `Set<T>` with `new SvelteSet(iterable?)` and an `add(value)` method. `SvelteURL` extends `URL` with a reactive `searchParams` property of type `SvelteURLSearchParams`, which itself extends `URLSearchParams` and has a `[REPLACE](params: URLSearchParams)` method. `createSubscriber`, also since 5.7.0, returns a `subscribe` function that calls `start` with an `update` function inside an effect, triggering re-runs when `update` is called. `start` can return a teardown function executed when the effect is destroyed. Multiple `subscribe` calls share the same `start` lifecycle. Example implementation of `MediaQuery` using `createSubscriber`: `class MediaQuery { #query; #subscribe; constructor(query) { this.#query = window.matchMedia(\`(${query})\`); this.#subscribe = createSubscriber(update => { const off = on(this.#query, 'change', update); return () => off(); }); } get current() { this.#subscribe(); return this.#query.matches; } }`. `createSubscriber` signature: `function createSubscriber(start: (update: () => void) => (() => void) | void): () => void;`.

`svelte/server` provides `render`, which is only available on the server when compiled with the `server` option. It takes a component and returns an object containing `body` and `head` properties for populating the HTML during server-side rendering. Usage: `render<Component, Props>(component, options?)`. The component must be a `SvelteComponent` or generic `Component`. The `options` parameter is optional if `Props` is an empty object and required otherwise. It can include `props` (excluding `$$slots` and `$$events`), `context` (a `Map<any, any>` for providing context to the component tree), and `idPrefix` (a string for scoping generated element IDs). The return type is `RenderOutput`.

`derived` creates a readable store by synchronizing multiple readable stores and applying a transformation function: `derived(stores, fn, initial_value?)` where `fn` receives `stores` values, a `set` function to update output, and an `update` function to modify the current value; an alternative form returns `fn(values)`. `fromStore` extracts the current value from a writable store as `{ current: V }` or from a readable store as `{ readonly current: V }`. `get(store)` retrieves the current store value by subscribing and immediately unsubscribing. `readable(value?, start?)` creates a store that allows reading via subscriptions. `readonly(store)` creates a derived store that is only readable. `toStore(get, set?)` converts a getter and optional setter into a writable store or a readable store if only `get` is provided. `writable(value?, start?)` creates a store supporting both reading and writing. The `Readable<T>` interface provides `subscribe(run, invalidate?)` where `run` is the callback receiving updates and `invalidate` handles cleanup. `StartStopNotifier<T>` is a function triggered when the first subscriber subscribes, accepting `set(value)` and `update(fn)`, optionally returning a cleanup function. `Subscriber<T>` is a callback receiving store updates. `Unsubscriber` is a function that unsubscribes from updates. `Updater<T>` is a function that modifies a value based on the current state. `Writable<T>` extends `Readable<T>`, adding `set(value)` to update the store and notify subscribers and `update(updater)` to apply an `Updater<T>` function and notify subscribers.

"svelte/transition" provides transition functions for animating elements. "blur" applies a blur filter and opacity change (`blur(node, { delay, duration, easing, amount, opacity })`). "crossfade" creates `send` and `receive` transitions where elements move and fade between states, using a `fallback` if no counterpart exists (`crossfade({ fallback, ...defaults })`). "draw" animates the stroke of SVG paths, starting from invisible (`draw(node, { delay, speed, duration, easing })`). "fade" adjusts opacity between 0 and the element's current opacity (`fade(node, { delay, duration, easing })`). "fly" animates x/y positions and opacity, transitioning between provided values and defaults (`fly(node, { delay, duration, easing, x, y, opacity })`). "scale" changes an element’s scale and opacity (`scale(node, { delay, duration, easing, start, opacity })`). "slide" moves an element along a specified axis (`slide(node, { delay, duration, easing, axis })`). Parameters include `BlurParams` (`delay`, `duration`, `easing`, `amount`, `opacity`), `CrossfadeParams` (`delay`, `duration`, `easing`), `DrawParams` (`delay`, `speed`, `duration`, `easing`), `FadeParams` (`delay`, `duration`, `easing`), `FlyParams` (`delay`, `duration`, `easing`, `x`, `y`, `opacity`), `ScaleParams` (`delay`, `duration`, `easing`, `start`, `opacity`), and `SlideParams` (`delay`, `duration`, `easing`, `axis`). `EasingFunction` is defined as `(t: number) => number`. `TransitionConfig` includes `delay`, `duration`, `easing`, `css(t, u)`, and `tick(t, u)`.

---
---
---

# SVELTEKIT 

A typical SvelteKit project has the structure: my-project/ with key directories and files such as src/, static/, tests/, and configuration files like package.json, svelte.config.js, tsconfig.json, and vite.config.js. In src/, the lib/ folder contains reusable library code, server/ contains server-only code, params/ includes param matchers, and routes/ holds the app's routes and components. app.html is the page template, with placeholders for head, body, assets, nonce, and environment variables. error.html handles errors with placeholders for status and error message. hooks.client.js and hooks.server.js define client and server hooks, while service-worker.js handles service workers. Static assets like robots.txt go in static/, and if Playwright was added for testing, tests reside in tests/. The package.json must include @sveltejs/kit, svelte, and vite as dependencies. The svelte.config.js file contains SvelteKit configurations, and tsconfig.json manages TypeScript settings. vite.config.js configures Vite. The .svelte-kit directory stores generated files, which can be ignored or deleted, as they will be recreated upon building or developing.

SvelteKit uses the Fetch API for network data, accessible in hooks and server routes. Request instances, available as event.request, have methods like request.json() and request.formData() for handling posted data. Response instances, returned by await fetch(...), turn a Request into a response. The Headers interface lets you access and modify request and response headers, e.g., request.headers.get('user-agent') and use the json function for sending responses with modified headers. Handling HTML form submissions involves FormData objects, where you access fields with body.get('name') or log fields with console.log([...body]). For large data or chunked responses, use the Streams API with ReadableStream, WritableStream, and TransformStream. URLs are managed by the URL interface with properties like origin and pathname, and query parameters are accessed via url.searchParams.get('foo'). The Web Crypto API is available via the crypto global, useful for tasks like generating UUIDs (crypto.randomUUID()) and internal security measures like Content Security Policy headers.

# ROUTING

SvelteKit uses a filesystem-based router where routes are defined by directories in the codebase; for instance, `src/routes` creates the root route, `src/routes/about` creates `/about`, and `src/routes/blog/[slug]` creates a parameterized route for dynamic data like `/blog/hello-world`. The directory for routes can be changed via project config. Route directories contain files prefixed with a `+` symbol to define functionality; for example, `+page.svelte` creates a page component, which is rendered both server-side (SSR) for the initial request and client-side (CSR) for subsequent navigation. Files like `+server.js` only run on the server, while `+page.svelte` works on both server and client. The `+page.svelte` component may receive data via the `data` prop, such as in `src/routes/blog/[slug]/+page`, where `let { data }: PageProps = $props();` binds the data passed to the page. A `+page.js` file can export a `load` function to fetch data, like in `src/routes/blog/[slug]/+page`, where the load function handles dynamic content loading, and it can also export options such as `prerender`, `ssr`, and `csr` to control rendering behavior. For data-specific server-side logic, rename `+page.js` to `+page.server.js` and change the type to `PageServerLoad`, such as in `src/routes/blog/[slug]/+page.server.js`, where server-specific logic like fetching data from a database can be implemented. The response from `+page.server.js` must be serializable. If needed, `+page.server.js` can also handle actions to interact with data, for example, via forms. When a load function throws an error, SvelteKit will render a default error page, but custom error pages can be created with `+error.svelte`, which can be used to handle errors per route, and SvelteKit walks up the directory structure to find the nearest `+error.svelte` file for error handling. If no matching error file is found, a default static error page can be customized in `src/error.html`. Layouts like `+layout.svelte` can be used to render persistent elements (e.g., navigation, footers) across pages by rendering the `children` component with `{@render children()}`. For instance, a `src/routes/+layout.svelte` file can define a global navigation, and `src/routes/about/+page.svelte` will render a page with a static layout. Layouts can also be nested; for example, `src/routes/settings/+layout.svelte` can be used for a `/settings` route with submenu items, and the nested layout can inherit properties from the root layout. Layouts can have their own `load` functions defined in `+layout.js` to fetch data; for instance, in `src/routes/settings/+layout.js`, a load function can return dynamic data like sections for the settings menu. Child pages can access layout data automatically via `PageProps` like `let { data }: PageProps = $props();`. A server-specific layout can be defined in `+layout.server.js`, which behaves similarly to `+page.server.js` and can also export page options like `prerender`, `ssr`, and `csr`. Server-side route logic can also be handled via `+server.js` files, which are API routes that correspond to HTTP verbs like GET, POST, etc., allowing full control over responses; for instance, `src/routes/api/random-number/+server.js` demonstrates how to handle GET requests and return a random number, with error handling via `error()` from `@sveltejs/kit`. Server responses can be streamed using the `Response` constructor or methods like `json` and `redirect`. `+server.js` files are not affected by layout files, and logic intended to run before every request should be placed in the server handle hook. +server.js files allow creating a full API by exporting handlers for HTTP methods like POST, PUT, PATCH, DELETE, OPTIONS, and HEAD. For example, in `src/routes/add/+page.svelte`, a simple form binds inputs to variables and sends a POST request to `/api/add` using the `fetch` API, sending JSON data and receiving a response with the total of two numbers. The corresponding `src/routes/api/add/+server.js` file defines a POST handler using `RequestHandler` to process the request and return the sum as JSON. Form actions are preferred for submitting data due to better handling in SvelteKit. A fallback method handler, defined using `export const fallback: RequestHandler`, will catch any unhandled HTTP methods like PUT or DELETE, and respond with a message indicating the caught request type. For HEAD requests, the GET handler takes precedence over the fallback. SvelteKit also supports content negotiation in `+server.js` files, where requests with a priority for `text/html` in the accept header are treated as page requests, while others like POST or PUT are processed as API endpoints. This content negotiation ensures GET responses include a `Vary: Accept` header for proper caching. When using TypeScript, SvelteKit creates a `$types.d.ts` file to provide type safety, with types like `PageProps` and `LayoutProps` available for annotating data received in components. These types, introduced in SvelteKit 2.16.0, replace manual typing of properties like `PageData` and `LayoutData`, and are used in components such as `+page.svelte` or `+layout.svelte`. Additionally, annotating functions like load with `PageLoad`, `PageServerLoad`, `LayoutLoad`, or `LayoutServerLoad` ensures proper typing of parameters and return values. Type annotations can be omitted in supported IDEs such as VS Code, which automatically inserts the correct types for you. Any other files within a route directory, like components or utility modules, are ignored by SvelteKit, making it possible to colocate them with the routes that require them. For reusable components across routes, it’s recommended to place them in `$lib`.

# LOADING DATA

SvelteKit uses load functions to retrieve data before rendering a +page.svelte component or its containing +layout.svelte components. A +page.svelte file can have a sibling +page.js that exports a load function, and its return value is accessible via the data prop, e.g., `let { data }: PageProps = $props();`. Prior to version 2.16.0, page and layout props were typed individually. A load function in +page.js runs on both server and browser by default unless `ssr = false` is set, in which case it runs only in the browser. For server-only operations, a +page.server.js is used, e.g., `export const load: PageServerLoad = async ({ params }) => { return { post: await db.getPost(params.slug) }; };`. Layout data can be loaded through +layout.js or +layout.server.js files, with layoutProps introduced in SvelteKit 2.16.0 to provide full type safety for layout data. Multiple load functions can return data with the same key, with the last one "winning." The +page.svelte component and all parent +layout.svelte components have access to their own data and their parents' data. Page data can also be accessed from parent layouts using page.data, e.g., `<title>{page.data.title}</title>`. Universal load functions in +page.js and +layout.js run both on the server during SSR and in the browser after hydration, while server load functions in +page.server.js and +layout.server.js run only on the server. The distinction between universal and server load functions is important; universal functions are ideal for fetching external API data, while server load functions are needed for server-side data like from a database or private environment variables. The `ServerLoadEvent` and `LoadEvent` provide context and access to parameters, route, and URL data for both types of load functions. A universal load function can return any values, including Svelte component constructors, while server load functions must return serializable data (e.g., JSON, BigInt, Date) that can be transported over the network. In cases where both server and universal load functions are used, the server load function’s result is passed as the data property to the universal load function. URL data such as `url`, `route`, and `params` are provided to load functions, with `url` giving access to the origin, hostname, pathname, and searchParams (excluding hash during SSR), `route` containing the route directory, and `params` representing dynamic parts of the URL path.

To make fetch requests from an external API or a `+server.js` handler, use the `fetch` function, which acts like the native `fetch` API with added features: it supports credentialed requests on the server by inheriting `cookie` and `authorization` headers, allows relative requests on the server, and routes internal requests (e.g., for `+server.js` routes) directly to the handler function, bypassing HTTP overhead. During server-side rendering, the response is captured and inlined into the rendered HTML using the `text`, `json`, and `arrayBuffer` methods, but headers are only serialized if explicitly included via [`filterSerializedResponseHeaders`]. During hydration, the response is read from the HTML, ensuring consistency and preventing additional network requests. For example, in a `+page.js` file: ```js /// file: src/routes/items/[id]/+page.js /** @type {import('./$types').PageLoad} */ export async function load({ fetch, params }) { const res = await fetch(`/api/items/${params.id}`); const item = await res.json(); return { item }; } ``` This shows fetching data for an item using a relative URL in the server-side `load` function.

A server `load` function can get and set [`cookies`]. For example, in `src/routes/+layout.server.js`: ```js /// file: src/routes/+layout.server.js // @filename: ambient.d.ts declare module '$lib/server/database' { export function getUser(sessionid: string | undefined): Promise<{ name: string, avatar: string }> } // @filename: index.js // ---cut--- import * as db from '$lib/server/database'; /** @type {import('./$types').LayoutServerLoad} */ export async function load({ cookies }) { const sessionid = cookies.get('sessionid'); return { user: await db.getUser(sessionid) }; } ``` Cookies are passed through the `fetch` function only if the target host is the same as the SvelteKit app or a subdomain. For example, if SvelteKit serves `my.domain.com`: - `domain.com` does NOT receive cookies - `my.domain.com` DOES - `api.domain.com` does NOT - `sub.my.domain.com` DOES. Cookies aren’t passed with `credentials: 'include'` because SvelteKit doesn't know which domain the cookie belongs to, so it's unsafe to forward them. Use the [handleFetch hook] to handle this.

Both server and universal `load` functions have access to a `setHeaders` function, which can set headers for the response when running on the server (it has no effect in the browser). This is useful for caching the page, for example: ```js /// file: src/routes/products/+page.js /** @type {import('./$types').PageLoad} */ export async function load({ fetch, setHeaders }) { const url = `https://cms.example.com/products.json`; const response = await fetch(url); // Headers set during SSR, caching page HTML // for the same length as underlying data. setHeaders({ age: response.headers.get('age'), 'cache-control': response.headers.get('cache-control') }); return response.json(); } ``` You can only set a header once using `setHeaders`, even across separate `load` functions. `set-cookie` headers cannot be set with `setHeaders`—use `cookies.set(name, value, options)` instead.

A `load` function can access data from a parent `load` function using `await parent()`. For example, in `src/routes/abc/+layout.js`: ```js /// file: src/routes/abc/+layout.js /** @type {import('./$types').LayoutLoad} */ export async function load({ parent }) { const { a } = await parent(); return { b: a + 1 }; } ``` In `src/routes/abc/+page.js`: ```js /// file: src/routes/abc/+page.js /** @type {import('./$types').PageLoad} */ export async function load({ parent }) { const { a, b } = await parent(); return { c: a + b }; } ``` In `src/routes/abc/+page.svelte`, the values are rendered: ```svelte <script> /** @type {import('./$types').PageProps} */ let { data } = $props(); </script> <p>{data.a} + {data.b} = {data.c}</p> ``` Inside `+page.server.js` and `+layout.server.js`, `parent` returns data from parent `+layout.server.js` files. In `+page.js` or `+layout.js`, it returns data from parent `+layout.js` files. If a `+layout.js` is missing, `parent` behaves like `({ data }) => data`, returning data from parent `+layout.server.js` files that aren't shadowed. Be cautious not to create waterfalls with `await parent()`. For instance, `getData(params)` should be called first to avoid delayed renders: ```js /// file: +page.js declare function getData(params: Record<string, string>): Promise<{ meta: any }> /** @type {import('./$types').PageLoad} */ export async function load({ params, parent }) { const data = await getData(params); const parentData = await parent(); return { ...data, meta: { ...parentData.meta, ...data.meta } }; } ```

If an error is thrown during `load`, the nearest [`+error.svelte`] will be rendered. For [_expected_] errors, use the `error` helper from `@sveltejs/kit` to specify the HTTP status code and an optional message: ```js /// file: src/routes/admin/+layout.server.js import { error } from '@sveltejs/kit'; /** @type {import('./$types').LayoutServerLoad} */ export function load({ locals }) { if (!locals.user) { error(401, 'not logged in'); } if (!locals.user.isAdmin) { error(403, 'not an admin'); } } ``` Calling `error(...)` throws an exception, stopping execution from inside helper functions. For [_unexpected_] errors, SvelteKit invokes [`handleError`] and treats it as a 500 Internal Error.

To redirect users, use the `redirect` helper from `@sveltejs/kit` to specify the destination and a 3xx status code. Like `error(...)`, calling `redirect(...)` throws an exception, stopping execution from inside helper functions. Example: ```js /// file: src/routes/user/+layout.server import { redirect } from '@sveltejs/kit'; import type { LayoutServerLoad } from './$types'; export const load: LayoutServerLoad = ({ locals }) => { if (!locals.user) { redirect(307, '/login'); } }; ``` Don't use `redirect()` inside a `try {...}` block, as the redirect will immediately trigger the `catch` statement. In the browser, use `goto` from `$app.navigation` to navigate programmatically outside of a load function.

When using a server load, promises are streamed to the browser as they resolve, allowing the page to render before all data is available. For example, in `src/routes/blog/[slug]/+page.server.js`: ```js import type { PageServerLoad } from './$types'; export const load: PageServerLoad = async ({ params }) => { return { comments: loadComments(params.slug), post: await loadPost(params.slug) }; }; ``` This can be used for skeleton loading states in `src/routes/blog/[slug]/+page`: ```svelte <script lang="ts"> import type { PageProps } from './$types'; let { data }: PageProps = $props(); </script> <h1>{data.post.title}</h1> <div>{@html data.post.content}</div> {#await data.comments} Loading comments... {:then comments} {#each comments as comment} <p>{comment.content}</p> {/each} {:catch error} <p>error loading comments: {error.message}</p> {/await} ``` Be cautious when streaming data, as unhandled promise rejections can cause the server to crash. Use a noop-catch for promises outside `fetch`. Example in `src/routes/+page.server`: ```js import type { PageServerLoad } from './$types'; export const load: PageServerLoad = ({ fetch }) => { const ok_manual = Promise.reject(); ok_manual.catch(() => {}); return { ok_manual, ok_fetch: fetch('/fetch/that/could/fail'), dangerous_unhandled: Promise.reject() }; }; ``` On platforms that do not support streaming (e.g., AWS Lambda), responses are buffered and the page will only render once all promises resolve. Ensure proxies like NGINX don't buffer responses. Streaming works only with JavaScript enabled, and avoid returning promises from a universal load function for server-rendered pages. Once streaming starts, headers and status codes cannot be changed, so `setHeaders` and redirects are not allowed inside streamed promises.

SvelteKit runs all load functions concurrently during page rendering or navigation to avoid waterfall requests, and during client-side navigation, the results of multiple server load functions are grouped into one response. Once all load functions return, the page is rendered. SvelteKit tracks load function dependencies to prevent unnecessary reruns during navigation; for example, if navigating from `/blog/trying-the-raw-meat-diet` to `/blog/i-regret-my-choices`, the `+page.server.js` load reruns because `params.slug` changes, but the `+layout.server` load does not because its data remains valid. A load function calling `await parent()` reruns if a parent load is rerun. Dependencies are not tracked after a load function has returned; for example, accessing `params.x` inside a nested promise won't cause a rerun when `params.x` changes (a development warning is issued for this mistake). Search parameters are tracked separately from the rest of the URL, so changes like `?x=1` to `?x=2` will trigger a rerun, but changes like `?x=1&y=1` to `?x=1&y=2` won’t. If you want to untrack a specific dependency, use the `untrack` function, e.g., `untrack(() => url.pathname === '/')` to exclude `url.pathname` from triggering a rerun. Manual invalidation can be triggered using `invalidate(url)` to rerun functions dependent on that URL, or `invalidateAll()` to rerun all functions. A load function depends on a URL if it calls `fetch(url)` or `depends(url)`, and `invalidate(url)` reruns it. For example, `invalidate('https://api.example.com/random-number')` or `invalidate('app:random')` triggers a rerun. Load functions rerun in the following situations: when a referenced `params` or `url` property changes, when `url.searchParams.get(...)` or related methods change, when calling `await parent()` causes a rerun in a parent load function, when a child load function depends on a server load, when a URL dependency is invalidated using `invalidate(url)`, and when `invalidateAll()` is called. Changes to `params` and `url` can result from link clicks, form submissions, `goto`, or redirects. Rerunning a load function updates the `data` prop in the corresponding `+layout.svelte` or `+page.svelte`, preserving internal state. To reset state, use an `afterNavigate` callback or wrap components in a `{#key}` block. Regarding authentication, layout load functions don’t run on every request during client-side navigation, and layout and page loads run concurrently unless `await parent()` is called; if a layout load throws, the page load runs, but no data is received by the client. Use hooks for route protection before load functions, or auth guards in `+page.server.js` for route-specific protection. Putting an auth guard in `+layout.server.js` requires all child pages to call `await parent()` for protection, which may be less performant unless every child depends on data from `await parent()`.

# FORM ACTIONS

A +page.server.js file can export actions for POSTing data to the server using the <form> element, with client-side JavaScript being optional but able to enhance interactions. Default actions are defined by declaring an export const actions object with a default action, such as `export const actions = { default: async (event) => { // log user in } } satisfies Actions;` which can be invoked with a simple form (`<form method="POST">`) sending the data via POST to the server, as GET requests shouldn't have side effects. To invoke this from other pages, an action attribute can point to the page like `<form method="POST" action="/login">`. Named actions allow multiple actions per page and are defined similarly: `export const actions = { login: async (event) => { // log user in }, register: async (event) => { // register user } } satisfies Actions;`, with invocation using a query parameter (`<form method="POST" action="?/register">`). The formaction attribute on a button can post data to a different action than the parent form, for example, `<button formaction="?/register">Register</button>`. Named actions can't coexist with default actions, as posting to a named action without a redirect causes the query parameter to persist in the URL, which would interfere with subsequent default POST requests.

Each action gets a RequestEvent object, enabling data access via request.formData(); after processing (like logging in with a cookie), the action can return data accessible through the form property on the corresponding page and page.form globally until the next update. ```src/routes/login/+page.server.js import * as db from '$lib/server/db'; import type { PageServerLoad, Actions } from './$types'; export const load: PageServerLoad = async ({ cookies }) => { const user = await db.getUserFromSession(cookies.get('sessionid')); return { user }; }; export const actions = { login: async ({ cookies, request }) => { const data = await request.formData(); const email = data.get('email'); const password = data.get('password'); const user = await db.getUser(email); cookies.set('sessionid', await db.createSession(user), { path: '/' }); return { success: true }; }, register: async (event) => { // TODO register the user } } satisfies Actions; src/routes/login/+page <script lang="ts"> import type { PageProps } from './$types'; let { data, form }: PageProps = $props(); </script> {#if form?.success} <!-- this message is ephemeral; it exists because the page was rendered in response to a form submission. it will vanish if the user reloads --> <p>Successfully logged in! Welcome back, {data.user.name}</p> {/if}```

To handle validation errors, you can use the `fail` function to return an HTTP status code (commonly 400 or 422 for validation errors) and form data back to the user. This data is accessible via `page.status` for the status code and `form` for the data. In a SvelteKit route, you can handle this by using the `fail` function inside the actions object, such as `login: async ({ cookies, request }) => { const data = await request.formData(); const email = data.get('email'); const password = data.get('password'); if (!email) return fail(400, { email, missing: true }); const user = await db.getUser(email); if (!user || user.password !== db.hash(password)) return fail(400, { email, incorrect: true }); cookies.set('sessionid', await db.createSession(user), { path: '/' }); return { success: true }; }`. On the form page, you can check for these conditions using `{#if form?.missing}<p class="error">The email field is required</p>{/if}` and `{#if form?.incorrect}<p class="error">Invalid credentials!</p>{/if}`, while binding the form values like `<input name="email" type="email" value={form?.email ?? ''}>`. The returned data must be serializable as JSON, and its structure is flexible, allowing you to differentiate form submissions with properties like an `id`.

Redirects and errors work exactly the same as in the `load` function. In a SvelteKit action, you can use `redirect` to send a user to a different page, with the status code 303 commonly used for redirects. For example, in `login: async ({ cookies, request, url }) => { const data = await request.formData(); const email = data.get('email'); const password = data.get('password'); const user = await db.getUser(email); if (!user) return fail(400, { email, missing: true }); if (user.password !== db.hash(password)) return fail(400, { email, incorrect: true }); cookies.set('sessionid', await db.createSession(user), { path: '/' }); if (url.searchParams.has('redirectTo')) redirect(303, url.searchParams.get('redirectTo')); return { success: true }; }`. The `redirect` function is used when the URL contains a query parameter like `redirectTo`, redirecting the user accordingly.

After an action runs, the page re-renders with the action's return value available to the page as the `form` prop, and the page’s `load` functions will execute after the action completes. Note that the `handle` function runs before the action and does not rerun before the `load` functions. For instance, if `handle` is used to populate `event.locals` based on a cookie, you must manually update `event.locals` when setting or deleting the cookie in an action, as seen in `src/hooks.server: export const handle: Handle = async ({ event, resolve }) => { event.locals.user = await getUser(event.cookies.get('sessionid')); return resolve(event); };` and in `src/routes/account/+page.server: export const load: PageServerLoad = (event) => { return { user: event.locals.user }; }; export const actions = { logout: async (event) => { event.cookies.delete('sessionid', { path: '/' }); event.locals.user = null; } } satisfies Actions;`.

Progressive enhancement can be achieved by adding the `use:enhance` action to a form, allowing for enhanced interactions when JavaScript is available. The form must use `method="POST"` and target actions defined in a `+page.server.js` file, as `use:enhance` does not work with `method="GET"` or forms without a specified method. For example, in `src/routes/login/+page`, the form would look like `<form method="POST" use:enhance>`. Without arguments, `use:enhance` emulates native browser behavior, avoiding full-page reloads while updating `form`, `page.form`, and `page.status` upon a successful or invalid response, but only when the action is on the same page. If the form has a different action like `<form action="/somewhere/else" ...>`, the form state will not be updated. To ensure updates regardless of redirection, use `applyAction`. It resets the form element, invalidates all data with `invalidateAll` on a successful response, triggers `goto` on a redirect, renders the nearest `+error` boundary if an error occurs, and resets focus to the appropriate element.

To customize the behavior of `use:enhance`, you can provide a `SubmitFunction` that runs before the form is submitted and optionally returns a callback to run with the `ActionResult`. If a callback is returned, the default behavior is not triggered, but calling `update` will restore it. For instance, in `<form method="POST" use:enhance={({ formElement, formData, action, cancel, submitter }) => { return async ({ result, update }) => { ... }; }}>`, you can handle custom logic like showing or hiding loading UI. If you return a callback, you may need to manually apply part of the default behavior using `applyAction` as shown in `src/routes/login/+page: <script lang="ts"> import { enhance, applyAction } from '$app/forms'; let { form }: PageProps = $props(); </script> <form method="POST" use:enhance={({ formElement, formData, action, cancel }) => { return async ({ result }) => { if (result.type === 'redirect') { goto(result.location); } else { await applyAction(result); } }; }}>`. The behavior of `applyAction(result)` depends on `result.type`: `success` and `failure` set `page.status` to `result.status` and update `form` and `page.form` with `result.data` (even if the form action redirects), `redirect` calls `goto(result.location, { invalidateAll: true })`, and `error` renders the nearest `+error` boundary with `result.error`. Focus will be reset in all cases.

To implement progressive enhancement without `use:enhance`, you can add a custom event listener to the `<form>`. In `src/routes/login/+page`, you can use a normal event listener with `handleSubmit`, which prevents the default form submission, creates a `FormData` object, and sends it via `fetch`. The `ActionResult` is then deserialized using `deserialize` from `$app/forms`. Depending on the `result.type`, you can apply custom behavior: if `result.type === 'success'`, use `invalidateAll()` to rerun all `load` functions, and call `applyAction(result)` to update the form state. For example: `<form method="POST" onsubmit={handleSubmit}>`. You must deserialize the response using `deserialize`, as `JSON.parse()` isn't sufficient because form actions support returning objects like `Date` or `BigInt`. If a `+server.js` exists alongside `+page.server.js`, fetch requests will route to `+server.js` by default. To ensure the request targets an action in `+page.server.js`, add the custom header: `headers: { 'x-sveltekit-action': 'true' }`.

Form actions are the preferred way to send data to the server as they can be progressively enhanced, but you can also use `+server.js` files to expose other interactions, such as a JSON API. For example, in `src/routes/send-message/+page`, you can use `fetch('/api/ci', { method: 'POST' })` to trigger an API call with a button click, and the handler in `src/routes/api/ci/+server.ts` can process the request using `export const POST: RequestHandler = () => { ... };`. While form actions require `method="POST"`, some forms, like search inputs, don’t need to POST data. These can use `method="GET"` (or no method at all), which causes SvelteKit to treat them like `<a>` elements, using the client-side router. For example, `<form action="/search"><input name="q"></form>` submits to `/search?q=...` and invokes the `load` function, but doesn't trigger an action. You can control the router behavior using attributes like `data-sveltekit-reload`, `data-sveltekit-replacestate`, `data-sveltekit-keepfocus`, and `data-sveltekit-noscroll` on the `<form>`.

# PAGE OPTIONS

By default, SvelteKit renders (or prerenders) components on the server, sends them as HTML to the client, and re-renders in the browser for hydration. This can be controlled per-page via +page.js or +page.server.js, or for groups of pages using +layout.js or +layout.server.js; app-wide settings are exported from the root layout. Child layouts and pages override parent settings, allowing prerendering for the whole app or dynamic rendering for specific pages. Options can be combined, such as prerendering marketing pages, server-rendering dynamic pages for SEO, and using client-only rendering for the admin section. This flexibility makes SvelteKit versatile.

In Svelte, some routes can be prerendered as simple HTML files generated at build time by setting `export const prerender = true` in `+page.js`, `+page.server.js`, or `+server`; alternatively, setting `export const prerender = true` in the root `+layout.js` or `+layout.server.js` will prerender everything except routes explicitly marked as non-prerenderable using `export const prerender = false`. Routes with `prerender = true` are excluded from the dynamic SSR manifest, reducing server size. If you want to prerender a route but still include it in the manifest, use `export const prerender = 'auto'`. For apps entirely suitable for prerendering, use `adapter-static` for static file output. The prerenderer starts at the root and generates files for prerenderable pages or `+server.js` routes, scanning for `<a>` elements linking to other prerenderable pages, so generally no need to specify specific pages unless using `config.kit.prerender.entries` or an `entries` function in dynamic routes. While prerendering, `building` imported from `$app/environment` is true.

Prerendering also applies to `+server.js` files, which inherit default values from pages that fetch data from them, but are not affected by layouts. For instance, if a `+page.js` contains `export const prerender = true` and uses a `load` function to fetch data from a server route (e.g., `/my-server-route.json`), then the corresponding `src/routes/my-server-route.json/+server.js` will be treated as prerenderable unless it explicitly sets `export const prerender = false`. Pages are prerenderable only if any two users hitting them directly receive the same content, meaning dynamic, personalized data or any data that changes per user cannot be prerendered. While you can fetch personalized data in `onMount`, it may lead to a poorer experience due to initial loading states. Pages like `src/routes/blog/[slug]/+page.svelte` that load data based on parameters can still be prerendered. Accessing `url.searchParams` during prerendering is forbidden, and any such use should be confined to the browser, such as within `onMount`. Pages with actions cannot be prerendered because they require server handling of POST requests.

Prerendering writes to the filesystem, so conflicting routes with a directory and file having the same name (e.g., `src/routes/foo/+server.js` and `src/routes/foo/bar/+server.js`) will cause issues. To avoid this, always include a file extension (e.g., `src/routes/foo.json/+server.js` and `src/routes/foo/bar.json/+server.js`), which allows the files to coexist as `foo.json` and `foo/bar.json`. For pages, this problem is avoided by writing `foo/index.html` instead of `foo`. If you encounter an error like "The following routes were marked as prerenderable, but were not prerendered," it means the route (or parent layout) was marked with `export const prerender = true`, but it wasn’t reached by the prerendering crawler, causing errors when trying to access it. To fix this, ensure SvelteKit can find the route via links in `config.kit.prerender.entries` or the entries page option. Add dynamic routes (pages with `[parameters]`) to this list if not discovered through crawling other entry points. Pages not marked as prerenderable will not be crawled. Alternatively, ensure the route is linked from other prerendered pages with server-side rendering enabled or change `export const prerender = true` to `export const prerender = 'auto'`, which allows dynamic server rendering.

SvelteKit discovers pages to prerender by starting at entry points and crawling them. By default, non-dynamic routes (e.g., `/` and `/blog`) are considered entry points, while dynamic routes like `/blog/[slug]` require special handling. SvelteKit will prerender `/` and `/blog`, discovering new pages like `/blog/hello-world` through links, but in some cases, such pages might not exist or be on prerendered pages. To handle such cases, you can define the pages in `config.kit.prerender.entries` or export an `entries` function from a `+page.js`, `+page.server.js`, or `+server.js` in a dynamic route, such as in `src/routes/blog/[slug]/+page.server`. The `entries` function should return an array of objects (e.g., `{ slug: 'hello-world' }`), and can be asynchronous, enabling dynamic retrieval from a CMS or database. The route can then be marked as prerendered with `export const prerender = true`.

In SvelteKit, by default, pages are rendered on the server first and then hydrated on the client. Setting `ssr` to `false` renders an empty shell page instead, which can be useful if the page relies on browser-only globals like `document`, though it’s generally not recommended in most cases (see appendix). To disable SSR for a page, set `export const ssr = false;` in the `+page.js` file. If both `ssr` and `csr` are `false`, nothing will be rendered. Setting `ssr` to `false` in your root `+layout.js` makes your entire app client-rendered, turning it into an SPA. Even with `ssr` set to `false`, code relying on browser APIs should be imported in `+page.svelte` or `+layout.svelte` because page options can be overridden and need to be evaluated by importing your `+page.js` or `+layout.js` either on the server (if a runtime exists) or at build time for prerendering.

In SvelteKit, CSR (Client-Side Rendering) hydrates server-rendered HTML into an interactive client-side page. To disable CSR for pages that don’t need JavaScript (like blog posts or about pages), set `export const csr = false;` in the `+page.js`. This removes JavaScript from the client, meaning the page works with HTML and CSS only, `<script>` tags inside Svelte components are removed, form elements can't be progressively enhanced, links are handled with full-page navigation, and Hot Module Replacement (HMR) is disabled. CSR can be enabled during development by setting `export const csr = dev;` where `dev` is from `$app/environment`. By default, SvelteKit removes trailing slashes from URLs; visiting `/about/` redirects to `/about`. You can change this behavior by setting `export const trailingSlash = 'never'`, `'always'`, or `'ignore'` in `+layout.js` or `+layout.server.js`. If `trailingSlash` is `'always'`, routes like `/about` result in `/about/index.html`, while others create `/about.html`. Ignoring trailing slashes is not recommended due to potential SEO issues, as relative paths behave differently and `/x` and `/x/` are treated as separate URLs.

The `config` object is used for platform-specific configurations through adapters; the configuration shape depends on the adapter, and you should import the adapter's `Config` interface for type safety. For example, `export const config: Config = { runtime: 'edge' };` configures the app to use edge runtime. Configurations are merged at the top level (but not nested), meaning you only need to override upper-level values in child pages. For example, `export const config = { runtime: 'edge', regions: 'all' };` in `+layout.js` can be overridden in `+page.js` with `export const config = { regions: ['us1', 'us2'] };`, resulting in `{ runtime: 'edge', regions: ['us1', 'us2'] }`.

# STATE MANAGEMENT

In apps that span server and client, avoid shared state on the server since servers are stateless while browsers are stateful. Shared variables on the server can lead to data leaks, such as when the `user` variable is stored and used in shared server code like `let user; export const load: PageServerLoad = () => { return { user }; }; export const actions = { default: async ({ request }) => { const data = await request.formData(); user = { name: data.get('name'), embarrassingSecret: data.get('secret') }; } }`. Here, the `user` data will be shared across all users, which can result in one user's data being exposed to another. Instead, authenticate users with cookies and store data in a database. Also, avoid side effects in load functions such as writing to stores or global state, for example, `user.set(await fetch('/api/user').then(res => res.json()));` This introduces shared state. Instead, return the data directly like `export const load: PageServerLoad = async ({ fetch }) => { const response = await fetch('/api/user'); return { user: await response.json() }; };` or pass it through page data. Even if SSR isn’t used, avoid side-effects in load functions to keep the app easier to reason about.

To manage state with context in Svelte, app state and stores on the server utilize the context API by using `setContext` to attach state to the component tree, and `getContext` to retrieve it. For example, in `src/routes/+layout`, state is passed to child components by setting context with `setContext('user', () => data.user);`, and in `src/routes/user/+page`, it’s accessed with `const user = getContext('user');`. This allows reactive updates across components. When using SSR, updating context-based state in deeper components won’t reflect in the parent component since it was already rendered; however, with CSR (default), the value propagates upwards and updates components. To prevent flashing during state updates on hydration, it’s recommended to pass state down rather than up. If SSR is not used or planned in the future, state can be safely stored in a shared module without context.

In SvelteKit, component and page state is preserved during navigation. When navigating between routes, such as from `/blog/my-short-post` to `/blog/my-long-post`, existing layout, page components, and other elements are reused, updating the `data` prop without destroying or recreating components. This means lifecycle methods like `onMount` and `onDestroy` won’t rerun, and variables like `estimatedReadingTime` will not be recalculated. To make such values reactive, use `$derived` like `let wordCount = $derived(data.content.split(' ').length);`. For code that needs to rerun after navigation, use `afterNavigate` and `beforeNavigate`. This reusability also means UI states, like sidebar scroll positions, are preserved, and animations between changing values are easier. To fully destroy and remount a component on navigation, use the `{#key page.url.pathname}` block. For state that needs to persist across reloads or affect SSR, URL search parameters (e.g., `?sort=price&order=ascending`) are ideal; they can be set in links, forms, or programmatically with `goto('?key=value')` and accessed inside load functions via the `url` parameter or `page.url.searchParams`. For ephemeral state, like UI elements' open/closed state, which doesn’t need to persist across sessions, SvelteKit provides snapshots, which link component state to a history entry, so it persists when navigating away and back.


# ADVANCED ROUTING

In SvelteKit, rest parameters can be used when the number of route segments is unknown, such as with a route like /[org]/[repo]/tree/[branch]/[...file], where a request for /sveltejs/kit/tree/main/documentation/docs/04-advanced-routing.md results in parameters like org: 'sveltejs', repo: 'kit', branch: 'main', and file: 'documentation/docs/04-advanced-routing.md'. A route like src/routes/a/[...rest]/z/+page.svelte matches /a/z, /a/b/z, /a/b/c/z, and so on. It's important to validate the value of the rest parameter using a matcher function to ensure it’s correct. Rest parameters can also be used to handle custom 404 pages. For example, a structure like src/routes/marx-brothers/[...path]/+page with a load function that calls `error(404, 'Not Found')` will return a 404 for unrecognized paths. If no 404 handling is implemented, the handleError function catches them. Optional parameters, such as [[lang]]/home, allow both home and en/home to resolve to the same page, but they cannot follow a rest parameter, as parameters are matched greedily, and the optional parameter would always be unused. Route parameters can be restricted using matchers; for instance, a matcher in src/params/fruit might validate a "page" parameter to only accept 'apple' or 'orange', using a function like `export const match = (param: string): param is ('apple' | 'orange') => { return param === 'apple' || param === 'orange'; };`. This matcher is applied in routes like src/routes/fruits/[page=fruit]. When multiple routes can match a given path, sorting is applied based on specificity, such as a route without parameters having higher priority than one with parameters, or a matcher having higher priority than an unvalidated parameter. Optional and rest parameters are considered lower priority unless they are at the end of the path. Sorting resolves ties alphabetically. For example, a request to /foo-abc would match src/routes/foo-abc/+page.svelte, and /foo-def would match src/routes/foo-[c]/+page.svelte. Encoding issues arise with characters that can’t be used in filenames or URLs; to represent restricted characters like / or :, hexadecimal escape sequences can be used, e.g., [x+2f] for / and [x+3a] for :. Unicode escape sequences are also supported, with [u+nnnn] format for Unicode characters, allowing routes like src/routes/[u+d83e][u+dd2a]/+page.svelte for emojis. Special care is needed when dealing with TypeScript and directories starting with a dot, as in .well-known routes, which can be encoded as src/routes/[x+2e]well-known/.... Layout groups allow for custom layout hierarchies. By default, layouts mirror the route structure, but with grouping, routes like /dashboard can be grouped in a (app) folder with a separate layout, and marketing routes like /about can be grouped in a (marketing) folder. Layouts in these groups will not affect the URL, e.g., src/routes/(app)/dashboard will be accessible at /dashboard, and src/routes/(marketing)/about will be accessible at /about. Pages within these groups can be structured as src/routes/(app)/dashboard/+layout.svelte, and the layout for these pages will be determined by their position in the directory tree. To break out of the inherited layout hierarchy, pages can use the @ symbol, such as +page@[id].svelte, which resets to a specific layout like src/routes/(app)/item/[id]/+layout.svelte. Similarly, layouts themselves can reset using +layout@, e.g., src/routes/(app)/item/[id]/+layout@.svelte, which would reset its layout inheritance and apply the root layout. Layout groups are useful but can introduce complexity, so simpler approaches, like reusable load functions or components, can be used for cases where deep nesting of layout groups might not be necessary.

# HOOKS

In SvelteKit, hooks are app-wide functions that allow fine-grained control over framework behavior. There are three types of hook files: `src/hooks.server.js` for server hooks, `src/hooks.client.js` for client hooks, and `src/hooks.js` for universal hooks. These hooks run during app startup, making them useful for initializing services like databases. Server hooks include `handle`, which runs on each request, either during normal operation or prerendering, and allows modifying response headers, bodies, or bypassing SvelteKit's route handling. For example, `src/hooks.server` might use `handle` to return a custom response for requests to `/custom`, or modify response headers like `x-custom-header`. Requests for static assets are not handled by `handle`. The `locals` object in `handle` allows passing custom data, like user info, to server load functions or handlers, but modifying immutable headers requires cloning the response. The `resolve` function, used within `handle`, supports custom rendering options like `transformPageChunk` to modify HTML, `filterSerializedResponseHeaders` to include headers in serialized responses, and `preload` to determine which files should be preloaded. The `handleFetch` function allows modifying or replacing fetch requests during SSR or pre-rendering, and can also include cookies for cross-origin requests by manually setting the cookie header in `handleFetch`. Shared hooks like `handleError` can be added in both `src/hooks.server.js` and `src/hooks.client.js`, and handle errors thrown during loading or rendering, providing a safe error message for users while logging details for debugging. The `init` function runs once when the app starts, useful for asynchronous tasks like database connections, though be mindful of delaying hydration in the browser. Universal hooks in `src/hooks.js` include `reroute`, which modifies how URLs are mapped to routes, allowing for route translation (e.g., mapping `/de/ueber-uns` to `/de/about`). The `reroute` function can be asynchronous from version 2.18 onwards, allowing dynamic URL resolution based on backend data. Lastly, `transport` allows passing custom types like `Vector` across the server-client boundary, using `encode` and `decode` functions to serialize and deserialize data between server and client.

# ERRORS

SvelteKit handles errors differently based on location, type, and request nature. Error objects are represented as simple `{ message: string }` objects by default but can include extra properties like `code` or `id` (requires redefining the Error type in TypeScript). Expected errors are thrown using the `error` helper from `@sveltejs/kit`, e.g., `error(404, { message: 'Not found' })`, causing SvelteKit to set the response status and render an +error.svelte component with the error object. You can also add extra properties to the error object or pass a string directly, e.g., `error(404, 'Not found')`. Unexpected errors, which are any other exceptions, are not exposed to users and show a generic message: `{ "message": "Internal Error" }`. These are logged and processed in the `handleError` hook, where you can customize error handling (e.g., sending to a reporting service or modifying the error object). If an error occurs in `handle` or a +server.js request handler, SvelteKit responds with a fallback error page or a JSON representation based on the request's Accept headers. A custom error page can be added by creating `src/error.html` with placeholders like `%sveltekit.status%` and `%sveltekit.error.message%` for dynamic values. Errors in load functions result in rendering the nearest +error.svelte component, with the exception of errors in root `+layout.js` or `+layout.server.js`, which trigger the fallback error page. For TypeScript, you can customize error shapes by declaring an `App.Error` interface in `src/app.d.ts`, which must include a `message: string` property.

# LINK OPTIONS

In SvelteKit, <a> elements are used for navigation, and the app will navigate by importing code and calling load functions when the href points to a route within the app. You can customize link behavior using data-sveltekit-* attributes, applicable to both <a> and <form> elements with method="GET". The data-sveltekit-preload-data attribute starts preloading when a mouse hover (on desktop) or touchstart/mousedown event occurs, with "hover" causing preload on hover/touchstart, and "tap" on mousedown/touchstart. The default is "hover" set on the <body> element, and you can specify "tap" for delayed loading. The preloadData function can be called programmatically from $app/navigation. Data preloading will not occur if navigator.connection.saveData is true. The data-sveltekit-preload-code attribute preloads code based on values like "eager", "viewport", "hover", or "tap", where "eager" loads immediately and "viewport" preloads when the link enters the viewport. Note that preloading code requires more eager data preload values. These attributes will be ignored if reduced data usage is enabled. The data-sveltekit-reload attribute forces the browser to handle the link, causing a full-page reload, including for links with rel="external", which are also ignored during prerendering. The data-sveltekit-replacestate attribute ensures navigation does not create a new history entry but replaces the current one with pushState. The data-sveltekit-keepfocus attribute retains focus on the current element after navigation, mainly used for forms and not links. It should be avoided on links to not disrupt focus expectations for assistive technologies. The data-sveltekit-noscroll attribute prevents the default scroll-to-top behavior on internal navigation. You can disable any option by setting its value to "false", as shown with nested elements, or apply attributes conditionally using a conditional expression like data-sveltekit-preload-data={condition ? 'hover' : false}.

# SERVICE WORKERS

Service workers in SvelteKit act as proxies for network requests, allowing for offline functionality and faster navigation by precaching JS and CSS. If you create a `src/service-worker.js` or `src/service-worker/index.js`, it will be bundled and registered automatically, but you can change the location or disable automatic registration for custom logic. By default, service workers are registered with `navigator.serviceWorker.register('./path/to/service-worker.js');`. Inside the service worker, you can use the `$service-worker` module, which provides paths to static assets, build files, prerendered pages, app version strings, and deployment base paths. If `define` is specified in Vite config, it applies to both service workers and server/client builds. The example code caches the built app and static files eagerly and caches other requests on demand. Service workers listen to `install`, `activate`, and `fetch` events to manage caching and network requests, with a strategy to serve assets from the cache or fall back to the network. You should be cautious when caching, as stale data might be worse than no data, and large files like videos can strain the cache. During development, service workers aren’t bundled, and only browsers supporting modules in service workers can use them; in development, use `{ type: 'module' }` for manual registration. For type safety, you need to reference `@sveltejs/kit`, disable DOM typings, and cast `self` to `ServiceWorkerGlobalScope` to avoid errors. If you import `$env/static/public`, use `/// <reference types="../.svelte-kit/ambient.d.ts" />` or `// @ts-ignore`. While SvelteKit's service worker is simple, some may prefer to use external libraries like Workbox or Vite PWA plugin for more complex scenarios.


# SERVER-ONLY MODULES

SvelteKit prevents accidental exposure of sensitive data by using server-only modules to ensure private environment variables and server-side utilities are not included in frontend code. The `$env/static/private` and `$env/dynamic/private` modules can only be imported into server-only modules such as `hooks.server.js` or `+page.server.js`. The `$app/server` module, which includes a read function for accessing the filesystem, is also restricted to server-side imports. Custom server-only modules can be created by adding `.server` to the filename (e.g., `secrets.server.js`) or placing them in `$lib/server` (e.g., `$lib/server/secrets.js`). Any attempt to import server-only code into public-facing code (directly or indirectly) will trigger an error, even if only a safe export is used, such as `add` from `utils.js` when it indirectly imports `secrets.js`. This feature also applies to dynamic imports, including those with interpolated paths like `await import(\./${foo}.js\)`, though in development, illegal imports may not be detected the first time due to multiple dynamic imports in the chain. Unit testing frameworks like Vitest disable illegal import detection when running tests, based on `process.env.TEST === 'true'`.

# SNAPSHOTS

Ephemeral DOM state, like scroll positions or input values, is discarded when navigating between pages. To preserve input data, you can take a snapshot of the DOM state using `capture` and `restore` methods in a `+page.svelte` or `+layout.svelte`. For example, in `+page.svelte`, define a snapshot object with `capture` to return the value of `comment` and `restore` to set `comment` to a stored value: `let comment = $state(''); export const snapshot: Snapshot<string> = { capture: () => comment, restore: (value) => comment = value };`. When navigating away, `capture` is called before the page updates and stores the value in the history stack; when navigating back, `restore` is called with the stored value after the page updates. The data must be serializable to JSON for storage in `sessionStorage`, allowing restoration on page reload or after navigating back. Avoid returning large objects from `capture`, as they are retained in memory for the session and may exceed storage limits in extreme cases.

# SHALLOW ROUTING

Shallow routing in SvelteKit allows creating history entries without navigating, useful for features like modal dialogs where the user can navigate back to dismiss the modal. This prevents frustration when swiping back on mobile devices. To implement a modal using shallow routing, you can use `pushState` to associate state with a history entry. Example: `pushState('', { showModal: true });` and then display a `Modal` when `page.state.showModal` is true. The modal can be dismissed by navigating back, either through user interaction or a close callback that calls `history.back()`. The first argument of `pushState` is the URL (use '' for the current URL) and the second is the new page state, accessible via `page.state`, which can be type-safe with an `App.PageState` interface. To set page state without creating a new history entry, use `replaceState`. Shallow routing also enables rendering another `+page.svelte` inside the current page, such as opening a photo detail view without navigation. Use `preloadData` inside a click handler with `<a>` elements, or when the element or a parent uses `data-sveltekit-preload-data` to reuse existing requests. In the example, clicking a thumbnail prevents navigation, preloads the photo data, and uses `pushState` to set the state. If preloading fails, `goto` is called for navigation. Caveats include server-side rendering where `page.state` is always an empty object, and initial pages where state isn't applied until navigation occurs. Shallow routing requires JavaScript, so fallback behavior should be considered if JavaScript is unavailable.

# PACKAGING

SvelteKit can be used to build apps and component libraries via the @sveltejs/package package (npx sv create offers setup options). For apps, src/routes holds public-facing content, and src/lib contains the internal app library; for component libraries, src/lib is public-facing and src/routes may be used for documentation or demos. Running svelte-package from @sveltejs/package processes src/lib and outputs a dist directory, including preprocessed Svelte components and transpiled TypeScript to JavaScript. Type definitions (d.ts) are auto-generated for Svelte, JS, and TS files, requiring TypeScript >= 4.0.0; handwritten d.ts files are retained, but type generation should not be disabled. Version 1 of @sveltejs/package generated a package.json, now the project’s package.json is used and validated. The package.json fields include name (set your library's name), license (commonly MIT), files (specifying files to include, typically dist, with unnecessary files excluded via .npmignore), and exports (defining entry points, e.g., `export { Something } from 'your-library';` with conditions for type definitions and Svelte components). Svelte-aware tooling uses the svelte condition, while non-Svelte projects can use default. Adjust exports to provide more entry points, such as `./Foo.svelte` for direct component imports. The svelte field, now legacy, should still be used for compatibility. The sideEffects field is used to specify modules with side effects, such as global changes, to help bundlers optimize code via tree-shaking, and it is recommended to mark CSS files as having side effects. Type definitions should be included for non-TypeScript users. By default, @sveltejs/package generates types, but care must be taken with named exports (e.g., `./foo`) due to TypeScript's handling of export conditions. Using TypeScript's typesVersions feature or setting moduleResolution to bundler, node16, or nodenext in tsconfig helps resolve type definitions correctly. Avoid using SvelteKit-specific modules like $app/environment in libraries intended for broader use, and instead pass props for more generic code. Ensure proper aliases in svelte.config.js, not vite.config.js or tsconfig.json. Versioning should reflect whether changes are bug fixes, features, or breaking changes, with additions or removals from exports being breaking changes. Source maps can be created by enabling "declarationMap": true in tsconfig.json, and source files can be included in the package by adding src/lib to the files array in package.json. The svelte-package tool accepts options like --watch for rebuilds, --input for input directory, --output for output directory, --types for type definitions, and --tsconfig for custom config paths. Publishing is done via npm publish, and relative imports must include full paths with extensions, such as `./something/index.js`, with TypeScript requiring .js extensions even for .ts files.

# BEST PRACTICES

## AUTH

After user credentials are provided (e.g., username, password), users are authenticated for subsequent requests using either session identifiers or signed tokens like JSON Web Tokens (JWT). Session IDs are stored in databases, can be revoked immediately, but require a database query on each request. JWTs, stored client-side, are not checked against a datastore and can't be immediately revoked, offering improved latency and reduced datastore load. Auth cookies can be checked in server hooks, and if valid credentials are found, user information can be stored in locals.

## PERFORMANCE

SvelteKit optimizes performance by employing code-splitting, asset preloading, file hashing, request coalescing, parallel loading, data inlining, conservative invalidation, prerendering, and link preloading, although some performance bottlenecks may remain. For performance diagnostics, tools like Google PageSpeed Insights and WebPageTest are useful, and browser dev tools such as Chrome’s Lighthouse, Edge’s Network and Performance tools, Firefox’s Network and Performance, and Safari’s performance tools are beneficial. Testing in preview mode post-build is essential as dev mode performance differs. Backend performance can be improved using tools like OpenTelemetry or Server-Timing headers for API calls. Optimizing assets involves reducing image file sizes with the @sveltejs/enhanced-img package, compressing videos with tools like Handbrake, lazy-loading videos with preload="none", stripping audio from muted videos using FFmpeg, and correctly preloading fonts or subsetting them. For reducing code size, using the latest Svelte version (Svelte 5 > 4 > 3) and tools like rollup-plugin-visualizer can help identify large packages. Minimize third-party scripts and use server-side implementations for analytics or run third-party scripts in web workers with Partytown’s SvelteKit integration. Use dynamic imports for conditionally loaded components to avoid bundling everything statically. Eager preloading with link options can speed up client-side navigation. Non-essential data can be loaded lazily with promises in the object returned from load functions. Prevent waterfall issues by ensuring parallel resource loading, using modulepreload tags, and avoiding sequential requests in universal load functions by consolidating API calls or queries. Server load functions should minimize sequential database queries by combining them where possible. Hosting performance is enhanced by locating the frontend near the backend or deploying to the edge with SvelteKit adapters, using CDNs for image hosting, and ensuring HTTP/2 support. Following general web performance principles, such as Core Web Vitals, can further optimize performance.

## IMAGES

Images impact app performance, so optimize them by using formats like .avif and .webp, creating different sizes for various screens, and ensuring proper caching. Vite processes assets for performance, including inline hashing for caching. For images, use Vite’s built-in handling with imports like `import logo from '$lib/assets/logo.png'; <img src={logo} />`. The experimental @sveltejs/enhanced-img plugin automates image optimization, creating multiple sizes/formats (e.g., webp, avif) and stripping EXIF data. Set up by installing `@sveltejs/enhanced-img` and adding `enhancedImages()` to `vite.config.js`. Use `<enhanced:img src="./image.jpg" alt="description" />` for automatic picture formatting. Dynamic images are possible via manual imports, like `import MyImage from './path/to/image.jpg?enhanced'; <enhanced:img src={MyImage} />`, or use `import.meta.glob` with query `{ enhanced: true }` for iterating through image assets. Intrinsic dimensions (width and height) are auto-set to avoid layout shifts, but custom CSS can override. For responsive images, use `sizes` and `srcset` to adjust for different screen sizes (e.g., `sizes="(min-width: 1920px) 1280px, 640px"`). Apply transformations like blur using query parameters (e.g., `?blur=15`). For dynamic image handling from CDNs, consider libraries like `@unpic/svelte` or CDN-specific tools (e.g., Cloudinary, Contentful). For icons, prefer CSS-based solutions to avoid heavy .svelte file imports. Best practices include using Vite for meta tags, @sveltejs/enhanced-img for homepage images, and dynamic methods for user-generated content. Serve images via CDN to reduce latency and use high-resolution images for HiDPI devices. Optimize for mobile by specifying sizes for large images, prioritize LCP images with `fetchpriority="high"`, and avoid layout shifts by defining width and height. Always provide alt text to improve accessibility and avoid using em/rem units in image sizes to ensure proper scaling and layout.

## ACCESSIBILITY

SvelteKit ensures accessibility by default, leveraging Svelte’s compile-time checks, but developers remain responsible for implementing accessible practices. Client-side routing prevents full page reloads, so SvelteKit injects a live region to announce new page titles after navigation, requiring each page to have a unique `<title>` inside `<svelte:head>` (e.g., `<title>Todo List</title>`). Focus resets to `<body>` after navigation unless an element with `autofocus` is present. Custom focus management is possible with `afterNavigate` (e.g., `afterNavigate(() => document.querySelector('.focus-me')?.focus());`). `goto` preserves focus if `keepFocus` is set, but the focused element must persist after navigation. The default `lang="en"` in `src/app.html` should be updated for non-English content (e.g., `<html lang="de">`). Dynamic language setting is achieved via SvelteKit’s `handle` hook, replacing `"%lang%"` in `app.html` with the correct language (`handle: Handle = ({ event, resolve }) => resolve(event, { transformPageChunk: ({ html }) => html.replace('%lang%', get_lang(event)) })`).

## SEO

SvelteKit optimizes SEO by default through SSR, ensuring search engines index content more reliably than client-rendered JavaScript. While SSR can be disabled via `handle`, it's generally beneficial beyond SEO. Performance affects rankings through Core Web Vitals; SvelteKit's minimal overhead aids in high-performance builds, measurable via Lighthouse or PageSpeed Insights. URLs are normalized to prevent duplicate content issues. Each page should have unique `<title>` and `<meta name="description">` elements inside `<svelte:head>`, often derived from `page.data`. Sitemaps, which help search engines prioritize content, can be dynamically generated using an endpoint: `src/routes/sitemap.xml/+server` with `GET` returning an XML response. For AMP support, inline all styles in `svelte.config` via `inlineStyleThreshold: Infinity`, disable CSR in `+layout.server.js` with `export const csr = false`, add `<html amp>` to `app.html`, and use `transformPageChunk` with `amp.transform(buffer)` in `handle` inside `src/hooks.server`. To remove unused CSS, `dropcss` can be applied post-transformation: extract `<style amp-custom>` contents, process them with `dropcss({ css, html: markup }).css`, and reinsert them. If prerendering pages, validate transformed HTML using `amphtml-validator` within `handle` since real-time validation is slow.

# SVELTEKIT REFERENCE

Server: class(manifest: SSRManifest) init(options: ServerInitOptions): Promise respond(request: Request, options: RequestOptions): Promise
VERSION: string
error(status: number, body?: App.Error | string): never - Throws HTTP error
fail(status: number, data?): ActionFailure - Creates failure object
isActionFailure(e): boolean isHttpError(e, status?): boolean isRedirect(e): boolean - Type checks
json(data, init?): Response text(body, init?): Response - Response creators
normalizeUrl(url): {url: URL, wasNormalized: boolean, denormalize: fn} - Strips suffixes
redirect(status: 300-308, location: string | URL): never - Redirects request
Action: fn(event: RequestEvent) -> OutputData Actions: Record<string, Action> - Form action handlers
ActionResult: {type: 'success'|'failure'|'redirect'|'error', status: number, data?, location?}
Adapter: {name: string, adapt(builder): Promise, supports?, read?(config, route), emulate?(): Emulator}
BeforeNavigate: {cancel: fn} AfterNavigate: {type: string, willUnload: boolean}
AwaitedActions<T>: Union<ReturnType<T[keyof T]>>
Builder: {log, rimraf(dir), mkdirp(dir), config, prerendered, routes, createEntries(fn), findServerAssets(routes), generateFallback(dest), generateEnvModule(), generateManifest(opts), getBuildDirectory(name), getClientDirectory(), getServerDirectory(), getAppPath(), writeClient(dest), writePrerendered(dest), writeServer(dest), copy(from, to, opts), compress(dir)}
ClientInit: fn(): Promise
Cookies: {get(name, opts), getAll(opts), set(name, value, opts), delete(name, opts), serialize(name, value, opts)}
Handle: fn({event: RequestEvent, resolve}): Response
HandleClientError: fn({error, event, status, message})
HandleFetch: fn({event, request, fetch}): Response
HandleServerError: fn({error, event, status, message})
HttpError: {status: number, body: App.Error}
Load: fn(event: LoadEvent) -> OutputData
LoadEvent: {fetch, data, setHeaders(headers), parent(): Promise, depends(...deps), untrack(fn)}
Navigation: {from, to, type: string, willUnload: boolean, delta?, complete: Promise}
NavigationEvent: {params, route: {id}, url}
NavigationTarget: {params, route: {id}, url}
NavigationType: 'enter'|'form'|'leave'|'link'|'goto'|'popstate'
OnNavigate: {type: string, willUnload: boolean}
Page: {url, params, route: {id}, status, error, data, state, form}
ParamMatcher: fn(param: string) -> boolean
PrerenderOption: boolean|'auto'
Redirect: {status: 300-308, location: string}
RequestEvent: {cookies, fetch, getClientAddress, locals, params, platform, request, route: {id}, setHeaders(headers), url, isDataRequest, isSubRequest}
RequestHandler: fn(event: RequestEvent) -> Response
Reroute: fn({url}) -> string
ResolveOptions: {transformPageChunk?, filterSerializedResponseHeaders?, preload?}
RouteDefinition: {id, api, page, pattern, prerender, segments, methods, config}
SSRManifest: {appDir, appPath, assets, mimeTypes, client, nodes, routes, prerendered_routes, matchers, server_assets}
ServerInit: fn(): Promise
ServerLoad: fn(event: ServerLoadEvent) -> OutputData
ServerLoadEvent: {parent(): Promise, depends(...deps)}
Snapshot: {capture(): any, restore(snapshot)}
SubmitFunction: fn({action, formData, formElement, controller, submitter, cancel}) -> Promise
Transport: Record<string, {encode(value), decode(data)}>

`@sveltejs/kit/hooks` provides `sequence` for chaining multiple `handle` calls. `transformPageChunk` is applied in reverse order and merged; `preload` is applied in forward order, with the first option taking precedence; `filterSerializedResponseHeaders` behaves similarly to `preload`. In `src/hooks.server.ts`, `sequence` chains `Handle` functions like `first` and `second`, where each handles pre/post-processing and modifies `transformPageChunk`, `preload`, and `filterSerializedResponseHeaders`. `sequence(first, second)` outputs: first pre-processing, first preload, second pre-processing, second filterSerializedResponseHeaders, second transform, first transform, second post-processing, first post-processing. `sequence` allows flexible chaining and behavior customization.

`@sveltejs/kit/node/polyfills` provides `installPolyfills` to make web APIs like `crypto` and `File` available as globals. `installPolyfills()` does not return a value. In `@sveltejs/kit/node`, `createReadableStream` (since 2.4.0) converts a file on disk to a readable stream with `createReadableStream(file: string): ReadableStream`. `getRequest` handles incoming requests, with parameters `{request: import('http').IncomingMessage, base: string, bodySizeLimit?: number}` and returns a `Promise<Request>`; `setResponse` sets the response for `http.ServerResponse` with `setResponse(res: import('http').ServerResponse, response: Response): Promise<void>`. In `@sveltejs/kit/vite`, `sveltekit` returns the SvelteKit Vite plugins with `sveltekit(): Promise<import('vite').Plugin[]>`.

`$app/environment` provides environment values: `browser` (true if in the browser), `building` (true during build or prerendering), `dev` (true if dev server is running), and `version` (value of `config.kit.version.name`). All are constants: `browser` is boolean, `building` is boolean, `dev` is boolean, and `version` is string.

The `$app/forms` module provides `applyAction`, `deserialize`, and `enhance` functions for form handling. `applyAction` updates the form property and `page.status` with the given data and redirects to the nearest error page on failure, with a signature of `applyAction(result: import('@sveltejs/kit').ActionResult<Success, Failure>): Promise<void>`. `deserialize` deserializes form submission responses and is used as `deserialize(result: string): import('@sveltejs/kit').ActionResult<Success, Failure>`, for instance, `const result = deserialize(await response.text())`. `enhance` enhances a `<form>` element for JavaScript use, with a submit function that is called upon submission with the `FormData` and action. If `cancel` is invoked, submission is prevented. It can use an abort controller to cancel submissions if needed, and if a custom function is provided, it’s called with the server’s response. If nothing is returned, it defaults to updating the form prop with the data, updating `page.status`, resetting the form and invalidating all data on successful submission without a redirect, or redirecting as needed. You can override defaults by passing `reset: false` to prevent form reset and `invalidateAll: false` to avoid invalidating data. Its signature is `enhance(form_element: HTMLFormElement, submit?: import('@sveltejs/kit').SubmitFunction<Success, Failure>)`, and it returns an object with `destroy()` to clean up the enhancement.

The `$app/navigation` module includes functions like `afterNavigate`, `beforeNavigate`, `disableScrollHandling`, `goto`, `invalidate`, `invalidateAll`, `onNavigate`, `preloadCode`, `preloadData`, `pushState`, and `replaceState`. `afterNavigate` runs a callback when the component mounts or when navigating to a URL, and it remains active while the component is mounted (`afterNavigate(callback: (navigation: import('@sveltejs/kit').AfterNavigate) => void): void`). `beforeNavigate` intercepts navigation before it happens, allowing cancellation with `cancel()`, and if navigating away from the app, triggers a native unload confirmation dialog (`beforeNavigate(callback: (navigation: import('@sveltejs/kit').BeforeNavigate) => void): void`). `disableScrollHandling` disables default scroll handling during navigation updates, but it’s discouraged (`disableScrollHandling(): void`). `goto` enables programmatic navigation to a route with various options like keeping focus or invalidating data (`goto(url: string | URL, opts?: { replaceState?: boolean, noScroll?: boolean, keepFocus?: boolean, invalidateAll?: boolean, invalidate?: (string | URL | ((url: URL) => boolean))[], state?: App.PageState }): Promise<void>`). `invalidate` causes load functions to rerun if the URL matches or a predicate returns true (`invalidate(resource: string | URL | ((url: URL) => boolean)): Promise<void>`), and `invalidateAll` forces all load functions to rerun (`invalidateAll(): Promise<void>`). `onNavigate` runs a callback before navigating to a new URL, with support for promises and DOM update callbacks (`onNavigate(callback: (navigation: import('@sveltejs/kit').OnNavigate) => MaybePromise<(() => void) | void>): void`). `preloadCode` imports code for routes to speed up navigation without calling load functions (`preloadCode(pathname: string): Promise<void>`), while `preloadData` preloads a page’s code and calls its load function to prepare for navigation (`preloadData(href: string): Promise<{ type: 'loaded', status: number, data: Record<string, any> } | { type: 'redirect', location: string }>`). `pushState` creates a new history entry with `page.state`, useful for shallow routing (`pushState(url: string | URL, state: App.PageState): void`), and `replaceState` replaces the current history entry (`replaceState(url: string | URL, state: App.PageState): void`).

The `$app/paths` module provides `assets`, `base`, and `resolveRoute`. `assets` returns an absolute path matching `config.kit.paths.assets`, which defaults to `/_svelte_kit_assets` during development or preview when assets are not yet at their final URL, with possible values as `''`, `https://${string}`, `http://${string}`, or `/_svelte_kit_assets`. `base` is a string matching `config.kit.paths.base`, typically used in `<a href="{base}/your-page">Link</a>`, with possible values as `''` or `/${string}`. `resolveRoute` resolves a pathname by populating a route ID with parameters, for example, `resolveRoute('/blog/[slug]/[...somethingElse]', { slug: 'hello-world', somethingElse: 'something/else' })` returns `/blog/hello-world/something/else`. Its signature is `resolveRoute(id: string, params: Record<string, string | undefined>): string`.

The `$app/server` module provides the `read` function to read the contents of an imported asset from the filesystem, available since 2.4.0. Example usage: `const asset = read(somefile); const text = await asset.text();`. Its signature is `read(asset: string): Response`.

The `$app/state` module provides three read-only state objects: `navigating`, `page`, and `updated`. `navigating` represents an in-progress navigation, with properties like `from`, `to`, `type`, and `delta`, all null when no navigation is happening or during server rendering (`const navigating: import('@sveltejs/kit').Navigation | { from: null; to: null; type: null; willUnload: null; delta: null; complete: null; }`). `page` holds information about the current page, including URL, route parameters, form data, page state, and error status. Changes to `page` are only reflected with runes, not the legacy reactivity syntax (`const page: import('@sveltejs/kit').Page`). `updated` is a reactive value that starts as `false` and updates to `true` if a new app version is detected, with `updated.check()` forcing an immediate check (`const updated: { get current(): boolean; check(): Promise<boolean>; }`). This module was introduced in SvelteKit 2.12, replacing `$app/stores` in earlier versions.

The `$app/stores` module provides store-based equivalents of exports from `$app/state` for SvelteKit 2.12 or later. Importing from `$app/stores` gives access to `getStores`, `navigating`, `page`, and `updated`. `getStores` returns an object containing `page`, `navigating`, and `updated`. `navigating` is a readable store that holds a `Navigation` object during navigation (with properties `from`, `to`, `type`, and `delta` if `type === 'popstate'`), reverting to `null` after navigation finishes; it can only be subscribed to during component initialization on the server and at any time in the browser. `page` is a readable store containing page data and follows the same subscription behavior as `navigating`. `updated` is a readable store initialized to `false`; it updates to `true` when SvelteKit detects an app version change (if `version.pollInterval` is non-zero), and `updated.check()` forces an immediate check, irrespective of polling; it can also only be subscribed to during component initialization on the server and at any time in the browser.

The `$env/dynamic/private` module provides runtime environment variables, excluding those with `config.kit.env.publicPrefix` and including those with `config.kit.env.privatePrefix`. It cannot be imported into client-side code and cannot be used during prerendering. In dev, it includes `.env` variables; in prod, it depends on the adapter. Example: `import { env } from '$env/dynamic/private'; console.log(env.DEPLOYMENT_SPECIFIC_VARIABLE);`. `$env/dynamic/public` includes variables with `config.kit.env.publicPrefix` (default `PUBLIC_`) and can be exposed to client-side code. Avoid using dynamic variables during prerendering. Example: `import { env } from '$env/dynamic/public'; console.log(env.PUBLIC_DEPLOYMENT_SPECIFIC_VARIABLE);`. `$env/static/private` includes variables from `.env` and `process.env`, statically injected at build time for optimizations. Example: `import { API_KEY } from '$env/static/private';`. `$env/static.public` is similar but for public variables and replaces values at build time. Example: `import { PUBLIC_BASE_URL } from '$env/static/public';`.

In SvelteKit, files under `src/lib` are automatically accessible using the `$lib` import alias, and the directory for this alias can be changed in the config file. Example: `import Component from '$lib/Component.svelte';` allows importing a reusable component from `src/lib/Component`.

The `$service-worker` module is available only to service workers and provides several properties: `base` represents the deployment base path, calculated from `location.pathname`, and works correctly if deployed to a subdirectory; `build` is an array of URL strings for Vite-generated files, suitable for caching, and is empty during development; `files` is an array of URL strings for files in the static directory or as specified by `config.kit.files.assets`, customizable using `config.kit.serviceWorker.files`; `prerendered` is an array of pathnames for prerendered pages and endpoints, empty during development; `version` is useful for generating unique cache names based on `config.kit.version` to invalidate old caches.

Svelte project configuration is stored in `svelte.config.js`, used by SvelteKit and other tools. The `config` object includes `compilerOptions` for compilation, `extensions` (default `[".svelte"]`) for file types, `kit` for SvelteKit-specific settings, and other tool-related options. The `kit` object has several properties like `adapter` (used during `vite build` for platform-specific output), `alias` (sets import path replacements such as `'my-file': 'path/to/my-file.js'`), `appDir` (default `_app` for internal files and assets), and `csp` (configures Content Security Policy with directives like `script-src` and options for nonces or hashes for dynamic and prerendered pages). The `csrf` property handles cross-site request forgery protections, `embedded` controls whether the app is embedded inside another app, and `env` sets environment variables with `publicPrefix` and `privatePrefix` for safe client-side exposure. File locations are configured in `files` (e.g., `assets`, `hooks.client`, `hooks.server`). The `inlineStyleThreshold` (default 0) controls inline CSS size for faster page loads. `moduleExtensions` (default `[".js", ".ts"]`) defines file types for routing, and `outDir` (default `.svelte-kit`) specifies the build directory. Output settings include `preloadStrategy` (default `modulepreload`), `bundleStrategy` (`split`, `single`, `inline`), and asset inlining via Vite’s `assetsInlineLimit`. Paths configuration controls asset URLs and base path behavior, with `relative` asset paths (default true) for portability. Prerendering options like `concurrency`, `crawl`, and `entries` manage page generation and error handling for HTTP errors, missing IDs, and entry mismatches. Router settings define the `type` (default `pathname`) for route handling and `resolution` (default `client`) for client or server-based routing. The `serviceWorker` option controls service worker registration, and `typescript` allows customization of `tsconfig.json`. Version management, through `name` (default build timestamp or commit hash) and `pollInterval` (default 0), handles app updates to avoid navigation issues when new versions are deployed.

SvelteKit projects use Vite's CLI via npm scripts (`npm run dev`, `npm run build`, `npm run preview`): `vite dev` starts a development server, `vite build` builds a production version, and `vite preview` runs the production version locally. SvelteKit also includes its own CLI for project initialization: `svelte-kit sync` generates the `tsconfig.json` and types (importable as `./$types` in routing files). This command runs automatically when creating a new project as part of the npm lifecycle and typically doesn’t need to be manually executed.

The `RequestHandler` and `Load` types in SvelteKit accept a `Params` argument to type the params object; for instance, an endpoint might expect `foo`, `bar`, and `baz` params as `src/routes/[foo]/[bar]/[baz]/+server.ts` with `export const GET: RequestHandler<{ foo: string; bar: string; baz: string; }> = async ({ params }) => {...};`. However, this is cumbersome and less portable, especially when renaming directories like `[foo]` to `[qux]`. SvelteKit addresses this by generating `.d.ts` files for each endpoint and page, for example, `.svelte-kit/types/src/routes/[foo]/[bar]/[baz]/$types.d.ts`, which contains `export type RequestHandler = Kit.RequestHandler<RouteParams>` and `export type PageLoad = Kit.Load<RouteParams>`. These files can be imported into your endpoints and pages as siblings via TypeScript’s `rootDirs` option: `import type { RequestHandler } from './$types';` in `+server.ts` and `import type { PageLoad } from './$types';` in `+page.svelte`. Return types of load functions are available through `$types` as `PageData` and `LayoutData`, and the union of all Action return values is `ActionData`. From version 2.16.0, helper types like `PageProps` and `LayoutProps` are available; `PageProps` includes `data: PageData` and `form: ActionData` when actions are defined, and `LayoutProps` includes `data: LayoutData` and `children: Snippet`. Example: `let { data, form }: PageProps = $props();`. To enable this, your `tsconfig.json` or `jsconfig.json` should extend from `.svelte-kit/tsconfig.json`, which contains options that should generally not be overridden unless necessary. The default `tsconfig.json` generated by SvelteKit includes settings like `"compilerOptions": { "paths": { "$lib": ["../src/lib"], "$lib/*": ["../src/lib/*"] }, "rootDirs": ["..", "./types"] }`, with `include` for files like `ambient.d.ts`, `non-ambient.d.ts`, and `./types/**/$types.d.ts`, and `exclude` for `node_modules/**` and `service-worker` files. Additionally, SvelteKit requires settings in `.svelte-kit/tsconfig` like `"verbatimModuleSyntax": true` for correct type imports, `"isolatedModules": true`, `"noEmit": true`, and `"lib": ["esnext", "DOM", "DOM.Iterable"]` for compatibility. `$lib` is an alias for `src/lib` or the directory defined in `config.kit.files.lib`, providing easy access to common components. `$lib/server` is a subdirectory for server-only modules that cannot be imported into client-side code. The `app.d.ts` file includes ambient types like the `App` namespace, which contains types affecting SvelteKit features. The `Error` interface defines the shape of expected and unexpected errors, with expected errors thrown via the `error` function and unexpected ones handled by `handleError`. The `Locals` interface defines `event.locals`, accessible in server hooks and `+server.js` files. `PageData` outlines the shape of the page's shared data and `$page.data` store, with optional properties for data specific to certain pages. `PageState` defines the shape of `page.state`, manipulated via `$app/navigation`'s `pushState` and `replaceState`. Finally, `Platform` defines platform-specific context if provided by the adapter via `event.platform`.
